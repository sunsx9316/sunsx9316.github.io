<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> UITableView+FDTemplateLayoutCell计算行高一些缺陷的解决方法 · Jim Huang的博客</title><meta name="description" content="UITableView+FDTemplateLayoutCell计算行高一些缺陷的解决方法 - Jim Huang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://sunsx9316.github.io/atom.xml" title="Jim Huang的博客"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/sunsx9316" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">UITableView+FDTemplateLayoutCell计算行高一些缺陷的解决方法</h1><div class="post-info">Aug 26, 2018</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>UITableView动态行高一直是iOS的一个经典问题，在没有AutoLayout的时代，只能自己计算<strong>frame</strong>，然后返回给代理，非常痛苦。到了AutoLayout的时代，布局就变得简单多了，甚至于通过系统提供的API都能自动计算出行高。</p>
<p><a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell">UITableView+FDTemplateLayoutCell</a>就是<a href="https://github.com/sunnyxx">sunnyxx</a>大大的一个自动计算行高的框架。只要布局正确，通过它可以自动计算并缓存行高，非常方便。不过在使用上发现一些问题，也尝试去解决了。</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>需求是这样的，一个类似微博的页面，像这样：</p>
<img src="/sunsx9316/2018/08/26/UITableView-FDTemplateLayoutCell计算行高一些缺陷的解决方法/2018/08/26/UITableView-FDTemplateLayoutCell计算行高一些缺陷的解决方法/1320218-1fc431e9a8a7a4f9.jpg" title="微博图片">
<p>这应该是比较经典的布局，内容和图片都是不确定的，行高要根据实际数据计算。九宫格实现方式有很多，我这里是通过UICollectionView去实现的。这样的一个好处就是UICollectionView的高度可以通过它的<strong>collectionViewLayout</strong>对象获取，啥都不用算。不过会有一个问题，UICollectionView继承自UIScrollView，它的高度没法按照内容来全显示。所以即使布局正确，通过AutoLayout来计算行高也是不包括UICollectionView的，这个问题同样反映在一些UIView控件上。</p>
<p>这就十分蛋疼了，难道还要回到手算frame的时代？当然不是，是我还写啥博客。</p>
<p>我说下解决的几个方法。</p>
<p><strong>方法一（不推荐）</strong>：手动设置collectionView的高度，可以通过代码或者xib来设置，我这里是xib。</p>
<img src="/sunsx9316/2018/08/26/UITableView-FDTemplateLayoutCell计算行高一些缺陷的解决方法/2018/08/26/UITableView-FDTemplateLayoutCell计算行高一些缺陷的解决方法/1320218-decdeddd6bfaee61.png" title="xib">
<p>像这样手动指定collectionView的高度，然后赋值数据源的时候更新collectionView高度约束就可以了，让它的高度等于它的<strong>contentSize.height</strong>，这样就能全部显示了，其它UIView控件也能这么解决。但是这样在计算行高的时候会抛出非常多异常，都是约束的问题。我不是很清楚这是什么原因，按理说计算再后，赋值在前，应该不会这样。而且显示会出一些问题，计算的行高会不正确，有些许误差。</p>
<p><strong>方法二（推荐）</strong>：既然不能通过这种方式，那就绕个弯吧。去掉高度约束，计算出来的高就不包含collectionView的高。然后再手动加上collectionView的高返回给代理不就行了。不过看下<a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell">UITableView+FDTemplateLayoutCell</a>的拓展方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier</span><br><span class="line">configuration:(void (^)(id cell))configuration;</span><br></pre></td></tr></table></figure></p>
<p>只有一个设置cell数据源的block，正常情况下我们只需要把cell换成我们自己的类，然后赋值模型就行，缓存之类的框架会自动处理好。虽然我们可以获取到缓存高度之后再加上collectionView的高，但是这样还叫啥缓存，缓存就是不需要计算，直接取到就能用，那怎么办呢？<br>虽然可以通过<strong>Method Swizzling</strong>黑魔法交换方法实现，但是这并不是最优方法，往往是一些莫名其妙的bug的源泉，作为开发者应该尽量避免这种方式。所以最后我选择了通过分类的方式。思路是在框架计算完高度之后通过block返回，我们自行处理行高，加加减减，然后返回高度让框架缓存。<br>具体代码：<br>我们参考下框架这个方法的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier</span><br><span class="line">cacheByIndexPath:(NSIndexPath *)indexPath</span><br><span class="line">configuration:(void (^)(id cell))configuration &#123;</span><br><span class="line">if (!identifier || !indexPath) &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//命中缓存</span><br><span class="line">if ([self.fd_indexPathHeightCache existsHeightAtIndexPath:indexPath]) &#123;</span><br><span class="line">[self fd_debugLog:[NSString stringWithFormat:@&quot;hit cache by index path[%@:%@] - %@&quot;, @(indexPath.section), @(indexPath.row), @([self.fd_indexPathHeightCache heightForIndexPath:indexPath])]];</span><br><span class="line">return [self.fd_indexPathHeightCache heightForIndexPath:indexPath];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//计算行高</span><br><span class="line">CGFloat height = [self fd_heightForCellWithIdentifier:identifier configuration:configuration];</span><br><span class="line">[self.fd_indexPathHeightCache cacheHeight:height byIndexPath:indexPath];</span><br><span class="line">[self fd_debugLog:[NSString stringWithFormat: @&quot;cached by index path[%@:%@] - %@&quot;, @(indexPath.section), @(indexPath.row), @(height)]];</span><br><span class="line"></span><br><span class="line">return height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它先从缓存中寻找行高，命中之后直接返回。否则计算行高，存入缓存，然后返回。所以很简单，我们可以直接复制它的代码。写一个带编辑行高功能的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">typedef CGFloat(^editCellHeightAction)(id cell, CGFloat cellHeight);</span><br><span class="line"></span><br><span class="line">- (CGFloat)jh_heightForCellWithIdentifier:(NSString *)identifier</span><br><span class="line">cacheByIndexPath:(NSIndexPath *)indexPath</span><br><span class="line">configuration:(void (^)(id cell))configuration</span><br><span class="line">editAction:(editCellHeightAction)editAction &#123;</span><br><span class="line">if (!identifier || !indexPath) &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">// Hit cache</span><br><span class="line">if ([self.fd_indexPathHeightCache existsHeightAtIndexPath:indexPath]) &#123;</span><br><span class="line">[self fd_debugLog:[NSString stringWithFormat:@&quot;hit cache by index path[%@:%@] - %@&quot;, @(indexPath.section), @(indexPath.row), @([self.fd_indexPathHeightCache heightForIndexPath:indexPath])]];</span><br><span class="line">return [self.fd_indexPathHeightCache heightForIndexPath:indexPath];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CGFloat height = 0;</span><br><span class="line">//获取缓存中的cell</span><br><span class="line">UITableViewCell *templateLayoutCell = [self fd_templateCellForReuseIdentifier:identifier];</span><br><span class="line">//这里插入编辑行高的代码</span><br><span class="line">if (editAction) &#123;</span><br><span class="line">height = editAction(templateLayoutCell, [self fd_heightForCellWithIdentifier:identifier configuration:configuration]);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">height = [self fd_heightForCellWithIdentifier:identifier configuration:configuration];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[self.fd_indexPathHeightCache cacheHeight:height byIndexPath:indexPath];</span><br><span class="line">[self fd_debugLog:[NSString stringWithFormat: @&quot;cached by index path[%@:%@] - %@&quot;, @(indexPath.section), @(indexPath.row), @(height)]];</span><br><span class="line">return height;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用起来像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (CGFloat)tableView:(UITableView *)tableView</span><br><span class="line">heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">return [tableView jh_heightForCellWithIdentifier:@&quot;MineCell&quot; cacheByIndexPath:indexPath configuration:^(HeSquareCell *cell) &#123;</span><br><span class="line">//正常赋值数据源</span><br><span class="line">cell.model = self.model;</span><br><span class="line">&#125; editAction:^CGFloat(MineCell *cell, CGFloat cellHeight) &#123;</span><br><span class="line">//cellHeight是上面的block计算后回调过来的 所以直接加上额外的高度即可</span><br><span class="line">//因为缓存的关系这里只会走一次 所以可以放心写</span><br><span class="line">return cellHeight + [cell collectionViewHeightWithModel:self.model];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样高度就能正常显示了，而且也不会抛异常，还能享受框架带来的便利。<br><a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell">UITableView+FDTemplateLayoutCell</a>的接口设计很易于拓展，所以写起来很简单。还有个问题，我发现在使用这个框架的时候，如果<code>_tableView.tableFooterView = [[UIView alloc] init];</code>这句话写在注册cell之前，程序会crash，不造为啥。如果各位有更好的解决思路或者文中有错误的地方欢迎给我留言。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/08/26/APP切换主题的一些思考/" class="prev">PREV</a><a href="/2018/08/26/第一篇博客/" class="next">NEXT</a></div><div class="copyright"><p>© 2018 <a href="https://sunsx9316.github.io">Jim Huang</a> | Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>