<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> APP切换主题的一些思考 · jimhuang的博客</title><meta name="description" content="APP切换主题的一些思考 - jimhuang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/sunsx9316/favicon.png"><link rel="stylesheet" href="/sunsx9316/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://github.com/sunsx9316/atom.xml" title="jimhuang的博客"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/sunsx9316/atom.xml" title="jimhuang的博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/sunsx9316/" class="logo-link"><img src="/sunsx9316/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/sunsx9316/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/sunsx9316/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="https://github.com/sunsx9316" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">APP切换主题的一些思考</h1><div class="post-info">2018年8月26日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>APP内切换主题是比较常见的需要，蛮早就思考过这个问题。网上也有很多的解决方案，不过本质上其实都类似，无非是两种情况。</p>
<ul>
<li>如果需要实现类似手Q那样动态更换主题，那么主题一定是个配置文件，能够从服务器下载。</li>
<li>如果只要求能更换成本地的几套主题，那只通过代码初始化，写死也是可以的。</li>
</ul>
<p>说说两者的优缺点。</p>
<ul>
<li>第一种比较灵活，但是引入的配置文件肯定要求格式的通用，毕竟不太可能要求服务端针对不同的设备提供不同的配置。那么很多人或许会选择JSON或者XML之类的格式。这样就会导致可读性不那么好，也不太直观，而且也没办法在编译期就做代码检查。</li>
<li>第二种对比第一种就更直观，没有什么能比 <code>label.textColor = redColor</code> 这样的代码更易读了吧。同时因为是原生开发，也可以在编译期就做到代码检查，缺点就是灵活性差了些。</li>
</ul>
<p>所以要做的其实是选择适合自己的类型，还有如何能更简单的做到切换而已。这个轮子其实并不太适合项目，更多是作为思考。公司项目并不要求做到类似手Q那样动态切换主题，但是为了拓展性，我还是考虑通过配置文件去加载。</p>
<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>因为写主题配置是十分麻烦的事，我想要做到的效果是只写配置文件，代码里不需要写任何判断和设置的逻辑就能做到自动根据当前主题切换样式。所以要做的事分为以下几步：</p>
<ol>
<li>书写配置</li>
<li>程序读取配置</li>
<li>代码根据当前主题自动设置样式</li>
</ol>
<p>同时配置文件要求可读性良好，就算别人接手了这个模块也不需要熟悉特定的配置书写语法。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>因为是本地使用，那么可以不考虑通用性，为了开发简单，我们使用<code>Plist</code>写配置。为了可读性良好，且尽量不增加学习成本，我想做到最好写在配置里的就是类似 <code>label.textColor = redColor</code> 这样的赋值语句。那能不能做到这一点呢，当然可以，我们可以借助OC的KVC。KVC本身也支持keyPath这样的赋值方式，<code>&quot;label.textColor&quot;</code> 这样的字符串在KVC中会被解析成查找 <code>label</code> 下的 <code>textColor</code> 属性。所以我们在 <code>Plist</code> 里的 <code>key</code>就可以定义成 <code>&quot;label.textColor&quot;</code>，而 <code>value</code>就是颜色。</p>
<p>那么问题来了，<code>Plist</code> 只支持字符串、数字、日期、二进制流这几种有限的格式，那怎么让它支持颜色呢？很容易联想到颜色16进制的表示方式，比如白色使用16进制表示就是 <code>#FFFFFF</code>，所以直接使用字符串不就好了。但是问题没这么简单。</p>
<p>一种比较常见的需求是在不同的主题下需要显示不同图片 (比如我们就有白天和黑夜模式，黑夜模式的图片就要求暗一些。小声bb……)，颜色如果使用了 <code>#FFFFFF</code> 这样的方式设置，那么图片怎么办？图片可以根据图片名，但是程序需要知道这个字符串是什么才能把它转成对应的东西，所以就需要定一套简单的规则了。</p>
<p>字符串非常灵活，任意的组合可以得到完全不同的内容，所以对于这种情况，选择字符串类型是比较合适的。类似编译器，有一套自己的复杂的解析规则，会把字符串转换为语法树。我们不需要这么复杂，只是简单的格式就好，但是可以设计成拥有很强拓展性的模式。所以我们需要定义一些通用的接口，生成一些解析器，这会在第二步详细说明。</p>
<h3 id="读取配置"><a href="#读取配置" class="headerlink" title="读取配置"></a>读取配置</h3><p>这一步比较重要的是接口的设计，关乎到使用的方便性和未来的拓展性。</p>
<p>我们接着说第一步末尾说到的解析器。为什么要定义解析器呢？首先每一个 <code>Plist</code>的对象，值传过来都是个字符串，我们要根据里面字符串的格式判断它是应该解析成颜色，或者图片又或者是其它。每种情况都不一样，所以拆分成独立的解析器会更好。不过他们都用一个共同点，遵守同一个协议。协议我们这样定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 解析优先级</span><br><span class="line"></span><br><span class="line"> - JHThemeParserPriorityRequest: 最先解析</span><br><span class="line"> - JHThemeParserPriorityNormal: 普通</span><br><span class="line"> - JHThemeParserPriorityUnimportance: 最后解析</span><br><span class="line"> */</span><br><span class="line">typedef NS_ENUM(NSUInteger, JHThemeParserPriority) &#123;</span><br><span class="line">    JHThemeParserPriorityUnimportance,</span><br><span class="line">    JHThemeParserPriorityNormal,</span><br><span class="line">    JHThemeParserPriorityRequest = 1000,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@class JHTheme;</span><br><span class="line">@protocol JHThemeParserProtocol &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 解析优先级</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, assign, readonly) JHThemeParserPriority priority;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 唯一标识</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, copy, readonly) NSString *identify;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 是否在解析之后直接返回 YES会将解析结果让之后的解析器继续解析</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, assign, readonly) BOOL continueParse;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 是否能解析这个值</span><br><span class="line"></span><br><span class="line"> @param value 值</span><br><span class="line"> @return 是否能解析这个值</span><br><span class="line"> */</span><br><span class="line">- (BOOL)canParseValue:(id)value;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 解析具体实现</span><br><span class="line"></span><br><span class="line"> @param value 值</span><br><span class="line"> @param currentTheme 当前主题</span><br><span class="line"> @return 解析结果</span><br><span class="line"> */</span><br><span class="line">- (id)converValue:(id)value currentTheme:(JHTheme *)currentTheme;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>重要的是这两个方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)canParseValue:(id)value;</span><br><span class="line">- (id)converValue:(id)value currentTheme:(JHTheme *)currentTheme;</span><br></pre></td></tr></table></figure>

<p>第一个方法判断这个解析器能否解析这个字符串。</p>
<ul>
<li>如果返回 <code>true</code> ， 那么会接着调用<code>converValue:(id)value currentTheme:(JHTheme *)currentTheme</code>，让解析器自己内部进行解析。</li>
<li>如果返回 <code>false</code>，那么这个解析器就无法解析这个字符串，也不会有之后的调用了。</li>
</ul>
<p>举个简单的例子，这是颜色解析器内部的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@implementation JHThemeColorParser</span><br><span class="line">- (BOOL)canParseValue:(NSString *)value &#123;</span><br><span class="line">    if ([value isKindOfClass:[NSString class]] &amp;&amp; ([value hasPrefix:@&quot;c(&quot;] || [value hasPrefix:@&quot;C(&quot;]) &amp;&amp; [value hasSuffix:@&quot;)&quot;]) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)converValue:(NSString *)value currentTheme:(JHTheme *)currentTheme &#123;</span><br><span class="line">    //取出色值</span><br><span class="line">    value = [value substringWithRange:NSMakeRange(2, value.length - 3)];</span><br><span class="line">    NSArray &lt;NSString *&gt;*rgba = [value componentsSeparatedByString:@&quot;,&quot;];</span><br><span class="line">    //16进制</span><br><span class="line">    if (rgba.count == 1) &#123;</span><br><span class="line">        return [UIColor colorWithHexString:value];</span><br><span class="line">    &#125;</span><br><span class="line">    else if (rgba.count &gt;= 3) &#123;</span><br><span class="line">        CGFloat r = 0,g = 0,b = 0,a = 1;</span><br><span class="line">        r = rgba.firstObject.doubleValue / 255.0;</span><br><span class="line">        g = rgba[1].doubleValue / 255.0;</span><br><span class="line">        b = rgba[2].doubleValue / 255.0;</span><br><span class="line">        if (rgba.count &gt;= 4) &#123;</span><br><span class="line">            a = rgba[3].doubleValue;</span><br><span class="line">        &#125;</span><br><span class="line">        return [UIColor colorWithRed:r green:g blue:b alpha:a];</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>首先 <code>- (BOOL)canParseValue:(id)value</code> 这个方法的实现是判断值是否符合规则，这里我定义成符合 <code>c(#FFFFF)</code> 或者 <code>c(255,255,255)</code> 格式的字符串就可以解析。前者是颜色的16进制表示法，后者是通过指定RGB数字的颜色表示法。而下面只是对这个解析格式的实现而已。这样做的好处是如果想定义一套比较复杂的解析规则，只要实现协议，自己写解析逻辑就好了。比如除了颜色的，我还实现了一些类似宏的解析逻辑。像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)canParseValue:(NSString *)value &#123;</span><br><span class="line">    if ([value isKindOfClass:[NSString class]] &amp;&amp; ([value hasPrefix:@&quot;d(&quot;] || [value hasPrefix:@&quot;D(&quot;]) &amp;&amp; [value hasSuffix:@&quot;)&quot;]) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)converValue:(NSString *)value currentTheme:(JHTheme *)currentTheme &#123;</span><br><span class="line">    NSString *tempStr = [[value substringWithRange:NSMakeRange(2, value.length - 3)] stringByTrim];</span><br><span class="line">    NSDictionary *mapDic = currentTheme.defineMap;</span><br><span class="line">    id map = mapDic[tempStr];</span><br><span class="line">    if (map) &#123;</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)continueParse &#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (JHThemeParserPriority)priority &#123;</span><br><span class="line">    return JHThemeParserPriorityRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>场景是APP有一个主题色，如果按照上面只是通过指定颜色去写，那就会很麻烦，而且一旦主题色更换，也要全局修改。这个宏解析器就定义了一种字符串格式像这样 <code>d(mainColor)</code>。配置文件有一个独立的”宏字典”，解析器取出 <code>mainColor</code> 然后在”宏字典”里查找 <code>mainColor</code>对应的 <code>value</code>是什么，这个 <code>value</code> 我只要定义成<code>c(#FFFFF)</code> 或者其它解析器可以解析的格式，就可以做到类似宏定义的替换效果。需要注意的是 <code>- (BOOL)continueParse</code> 需要返回 <code>YES</code>，这样解析的结果才能返回给其它的解析器继续解析。</p>
<p>所以可以看到，这样是非常灵活的。</p>
<h3 id="自动设置样式"><a href="#自动设置样式" class="headerlink" title="自动设置样式"></a>自动设置样式</h3><p>这一步其实相对来说比较容易了，但是也有不少值得说的地方。我这里定义了一个叫 <code>themeManager</code> 的主题管理类。接口这样设计：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 自定义操作block</span><br><span class="line"></span><br><span class="line"> @param aObj 更改的对象</span><br><span class="line"> @param key 键</span><br><span class="line"> @param value 值</span><br><span class="line"> @return 自定义更改的对象</span><br><span class="line"> */</span><br><span class="line">typedef id(^JHThemeCustomAction)(id aObj, NSString *key, id value);</span><br><span class="line"></span><br><span class="line">@class JHThemeManager;</span><br><span class="line">@protocol JHThemeManagerObserver&lt;NSObject&gt;</span><br><span class="line">@optional</span><br><span class="line">//主题改变回调</span><br><span class="line">- (void)themeManager:(JHThemeManager *)themeManager didChangeTheme:(JHTheme *)theme;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface JHThemeManager : NSObject</span><br><span class="line">+ (instancetype)shareThemeManager;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong, readonly) JHTheme *currentTheme;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 注册自定义解析器</span><br><span class="line"></span><br><span class="line"> @param parserClass 解析器需要实现 JHThemeParserProtocol接口</span><br><span class="line"> */</span><br><span class="line">- (void)registerParser:(Class)parserClass;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 添加单个主题</span><br><span class="line"></span><br><span class="line"> @param theme 主题对象</span><br><span class="line"> */</span><br><span class="line">- (void)addTheme:(JHTheme *)theme;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 添加多个主题</span><br><span class="line"></span><br><span class="line"> @param themes 主题数组</span><br><span class="line"> */</span><br><span class="line">- (void)addThemes:(NSArray &lt;JHTheme *&gt;*)themes;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 根据主题名称更改当前主题</span><br><span class="line"></span><br><span class="line"> @param themeName 主题名称</span><br><span class="line"> */</span><br><span class="line">- (void)updateThemeByName:(NSString *)themeName;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 根据当前主题更新对象的样式</span><br><span class="line"></span><br><span class="line"> @param obj 对象</span><br><span class="line"> @param themeKey 主题下的Key 空则为obj的类名</span><br><span class="line"> @param block 自定义操作</span><br><span class="line"> */</span><br><span class="line">- (void)updateObjStyleWithCurrentTheme:(id)obj</span><br><span class="line">                              themeKey:(NSString *)themeKey</span><br><span class="line">                                 block:(JHThemeCustomAction)block;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 根据当前主题更新对象的样式</span><br><span class="line"></span><br><span class="line"> @param obj 对象</span><br><span class="line"> @param themeKey 主题下的Key 空则为obj的类名</span><br><span class="line"> @param themeName 主题名称</span><br><span class="line"> @param block 自定义操作</span><br><span class="line"> */</span><br><span class="line">- (void)updateObjStyleWithCurrentTheme:(id)obj</span><br><span class="line">                              themeKey:(NSString *)themeKey</span><br><span class="line">                             themeName:(NSString *)themeName</span><br><span class="line">                                 block:(JHThemeCustomAction)block;</span><br><span class="line"></span><br><span class="line">- (void)addObserver:(id&lt;JHThemeManagerObserver&gt;)observer;</span><br><span class="line">- (void)removeObserver:(id&lt;JHThemeManagerObserver&gt;)observer;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p><code>- (void)registerParser:(Class)parserClass</code> 注册的是遵守了解析器协议的类，只有注册了才支持解析这种类型的字符串。内部实现是通过数组保存示例，解析的时候根据优先级循环调用已经注册的解析器进行解析。</p>
<p>然后重点是自动。因为我们的 <code>key</code> 是 <code>keyPath</code>的形式，所以直接通过KVC把解析结果赋值就行。</p>
<p>实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line">- (void)updateObjStyleWithCurrentTheme:(id)toObj</span><br><span class="line">                              themeKey:(NSString *)themeKey</span><br><span class="line">                             themeName:(NSString *)themeName</span><br><span class="line">                                 block:(JHThemeCustomAction)block &#123;</span><br><span class="line">    if (toObj == nil) return;</span><br><span class="line"></span><br><span class="line">    if (themeKey.length == 0) &#123;</span><br><span class="line">        themeKey = NSStringFromClass([toObj class]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    JHTheme *aTheme = nil;</span><br><span class="line">    if (themeName.length == 0) &#123;</span><br><span class="line">        aTheme = self.currentTheme;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        aTheme = [self themeByName:themeName];</span><br><span class="line">    &#125;</span><br><span class="line">    //获取当前主题所有存储的内容</span><br><span class="line">    NSDictionary *content = aTheme.content[themeKey];</span><br><span class="line">    if ([content isKindOfClass:[NSDictionary class]] == NO) return;</span><br><span class="line"></span><br><span class="line">    [content enumerateKeysAndObjectsUsingBlock:^(NSString * _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123;</span><br><span class="line"></span><br><span class="line">        //自定义修改</span><br><span class="line">        if (block) &#123;</span><br><span class="line">            obj = block(toObj, key, [self converValueWithObj:obj]);</span><br><span class="line">            if (obj == nil) return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NSString *cacheKey = [themeKey stringByAppendingFormat:@&quot;.%@&quot;, key];</span><br><span class="line">        NSNumber *cache = [self.keyPathCache objectForKey:cacheKey];</span><br><span class="line">        //没有缓存过</span><br><span class="line">        if (cache == nil) &#123;</span><br><span class="line">            NSArray &lt;NSString *&gt;*keyPaths = [key componentsSeparatedByString:@&quot;.&quot;];</span><br><span class="line"></span><br><span class="line">            id lastObj = toObj;</span><br><span class="line"></span><br><span class="line">            //单个key</span><br><span class="line">            if (keyPaths.count == 1) &#123;</span><br><span class="line">                //当前key不存在</span><br><span class="line">                BOOL exist = [lastObj respondsToSelector:NSSelectorFromString(keyPaths.firstObject)];</span><br><span class="line">                NSAssert(exist, @&quot;%@不存在 设置主题失败&quot;, key);</span><br><span class="line"></span><br><span class="line">                if (exist == false) &#123;</span><br><span class="line">                    cache = @(NO);</span><br><span class="line">                    [self.keyPathCache setObject:cache forKey:cacheKey];</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    cache = @(YES);</span><br><span class="line">                    [self.keyPathCache setObject:cache forKey:cacheKey];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //keyPath</span><br><span class="line">            else &#123;</span><br><span class="line">                BOOL flag = YES;</span><br><span class="line">                for (NSInteger i = 0; i &lt; keyPaths.count - 1; ++i) &#123;</span><br><span class="line">                    NSString *key = keyPaths[i];</span><br><span class="line">                    SEL selector = NSSelectorFromString(key);</span><br><span class="line">                    if ([lastObj respondsToSelector:selector]) &#123;</span><br><span class="line">                        lastObj = [lastObj valueForKey:key];</span><br><span class="line">                    &#125;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        flag = NO;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (flag) &#123;</span><br><span class="line">                    flag = [lastObj respondsToSelector:NSSelectorFromString(keyPaths.lastObject)];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                cache = @(flag);</span><br><span class="line">                [self.keyPathCache setObject:cache forKey:cacheKey];</span><br><span class="line">                if (flag == NO) &#123;</span><br><span class="line">                    NSLog(@&quot;%@不存在 设置主题失败&quot;, key);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //key无效</span><br><span class="line">        if (cache.boolValue == NO) return;</span><br><span class="line"></span><br><span class="line">        //多参数</span><br><span class="line">        if ([key containsString:@&quot;:&quot;]) &#123;</span><br><span class="line">            NSArray *separatedValues = [key componentsSeparatedByString:@&quot;.&quot;];</span><br><span class="line">            NSString *method = separatedValues.lastObject;</span><br><span class="line">            SEL aSEL = NSSelectorFromString(method);</span><br><span class="line">            //真正发消息的对象</span><br><span class="line">            id sendObj = [toObj valueForKeyPath:[key stringByReplacingOccurrencesOfString:[NSString stringWithFormat:@&quot;.%@&quot;, method] withString:@&quot;&quot;]];</span><br><span class="line"></span><br><span class="line">            NSArray *valueArr = [obj isKindOfClass:[NSArray class]] ? obj : @[obj];</span><br><span class="line">            YYClassMethodInfo *info = [[YYClassMethodInfo alloc] initWithMethod:class_getInstanceMethod([sendObj class], aSEL)];</span><br><span class="line">            //冒号之后的参数为实际参数</span><br><span class="line">            NSArray &lt;NSString *&gt;*argumentTypeEncodings = ^&#123;</span><br><span class="line">                NSInteger index = [info.argumentTypeEncodings indexOfObject:@&quot;:&quot;];</span><br><span class="line">                if (index != NSNotFound) &#123;</span><br><span class="line">                    return (NSArray *)[info.argumentTypeEncodings subarrayWithRange:NSMakeRange(index + 1, info.argumentTypeEncodings.count - index - 1)];</span><br><span class="line">                &#125;</span><br><span class="line">                return @[];</span><br><span class="line">            &#125;();</span><br><span class="line"></span><br><span class="line">            //参数个数和key的方法不一致</span><br><span class="line">            if (argumentTypeEncodings.count != valueArr.count) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            NSMethodSignature *sign = [sendObj methodSignatureForSelector:aSEL];</span><br><span class="line">            NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:sign];</span><br><span class="line">            invocation.target = sendObj;</span><br><span class="line">            invocation.selector = aSEL;</span><br><span class="line"></span><br><span class="line">            for (NSInteger idx1 = 0; idx1 &lt; argumentTypeEncodings.count; ++idx1) &#123;</span><br><span class="line">                id obj1 = valueArr[idx1];</span><br><span class="line">                id tempObj = [self converValueWithObj:obj1];</span><br><span class="line">                YYEncodingType encodingType = YYEncodingGetType(argumentTypeEncodings[idx1].UTF8String);</span><br><span class="line">                switch (encodingType) &#123;</span><br><span class="line">                    case YYEncodingTypeBool:</span><br><span class="line">                    &#123;</span><br><span class="line">                        BOOL aValue = [tempObj boolValue];</span><br><span class="line">                        [invocation setArgument:&amp;aValue atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case YYEncodingTypeInt8:</span><br><span class="line">                    &#123;</span><br><span class="line">                        char aValue = [tempObj charValue];</span><br><span class="line">                        [invocation setArgument:&amp;aValue atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case YYEncodingTypeUInt8:</span><br><span class="line">                    &#123;</span><br><span class="line">                        unsigned char aValue = [tempObj unsignedCharValue];</span><br><span class="line">                        [invocation setArgument:&amp;aValue atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case YYEncodingTypeInt16:</span><br><span class="line">                    &#123;</span><br><span class="line">                        short aValue = [tempObj shortValue];</span><br><span class="line">                        [invocation setArgument:&amp;aValue atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case YYEncodingTypeUInt16:</span><br><span class="line">                    &#123;</span><br><span class="line">                        unsigned short aValue = [tempObj unsignedShortValue];</span><br><span class="line">                        [invocation setArgument:&amp;aValue atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case YYEncodingTypeInt32:</span><br><span class="line">                    &#123;</span><br><span class="line">                        int32_t aValue = [tempObj intValue];</span><br><span class="line">                        [invocation setArgument:&amp;aValue atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case YYEncodingTypeUInt32:</span><br><span class="line">                    &#123;</span><br><span class="line">                        uint32_t aValue = [tempObj intValue];</span><br><span class="line">                        [invocation setArgument:&amp;aValue atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case YYEncodingTypeInt64:</span><br><span class="line">                    &#123;</span><br><span class="line">                        long long aValue = [tempObj longLongValue];</span><br><span class="line">                        [invocation setArgument:&amp;aValue atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case YYEncodingTypeUInt64:</span><br><span class="line">                    &#123;</span><br><span class="line">                        unsigned long long aValue = [tempObj unsignedLongLongValue];</span><br><span class="line">                        [invocation setArgument:&amp;aValue atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case YYEncodingTypeFloat:</span><br><span class="line">                    &#123;</span><br><span class="line">                        float aValue = [tempObj floatValue];</span><br><span class="line">                        [invocation setArgument:&amp;aValue atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case YYEncodingTypeDouble:</span><br><span class="line">                    &#123;</span><br><span class="line">                        double aValue = [tempObj doubleValue];</span><br><span class="line">                        [invocation setArgument:&amp;aValue atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case YYEncodingTypeLongDouble:</span><br><span class="line">                    &#123;</span><br><span class="line">                        long double aValue = [tempObj doubleValue];</span><br><span class="line">                        [invocation setArgument:&amp;aValue atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case YYEncodingTypeObject:</span><br><span class="line">                    &#123;</span><br><span class="line">                        [invocation setArgument:&amp;tempObj atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    default:</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //调用</span><br><span class="line">            [invocation invoke];</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            [toObj setValue:[self converValueWithObj:obj] forKeyPath:key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这么长一段代码，我都不想看😑，幸好还记得怎么实现的。按照上面我们说的，应该非常简单才对，但是实际上还要处理一些其他情况。举个例子，<code>UIButton</code> 在设置图片、文字颜色等属性的时候需要带上 <code>UIControlState</code>，那就需要传两个参数。<code>Plist</code>可以把这种多参数保存为数组，但是KVC就没办法做到赋值了，这时候就要借助到OC的运行时了。</p>
<p>我们知道，OC的方法调用，本质都是发送消息，而消息的参数是不确定的，所以我们可以借助底层提供的 <code>NSInvocation</code> 这种通过方法签名发消息的类。如果了解过OC的消息转发机制的同学，应该见过这个类。它其实是一个调用器，设置了方法签名，再设置了参数就可以像普通消息发送了。方法名我们定义成配置的 <code>key</code>，多参数就和OC的方法名一样，用”:”隔开，类似这样：<code>setImage:forState</code>，<code>value</code> 是一个数组。实现用了YYKit的一些方法，只是写起来简单一些，内部就是调用runtime的API，这样就做到了多参数的兼容。</p>
<p>然而实际使用的时候，其实很麻烦。有一个比较巧妙的方式是通过分类去添加参数。比如 <code>UIButton</code> 的 <code>setImage:forState</code>，我们可以添加这些分类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) UIImage *jh_normalImg;</span><br><span class="line">@property (nonatomic, strong) UIImage *jh_hightlightedImg;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>实现是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)setJh_normalImg:(UIImage *)jh_normalImg &#123;</span><br><span class="line">    [self setImage:jh_normalImg forState:UIControlStateNormal];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIImage *)jh_normalImg &#123;</span><br><span class="line">    return [self imageForState:UIControlStateNormal];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setJh_hightlightedImg:(UIImage *)jh_hightlightedImg &#123;</span><br><span class="line">    [self setImage:jh_hightlightedImg forState:UIControlStateHighlighted];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIImage *)jh_hightlightedImg &#123;</span><br><span class="line">    return [self imageForState:UIControlStateHighlighted];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过分类指定其它的参数就可以像单个参数那样使用了。</p>
<p>至于自动调用，其实很简单。我们给 <code>NSObject</code> 添加一个分类，实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@implementation NSObject (JHThemeManager)</span><br><span class="line"></span><br><span class="line">- (void)jh_updateTheme &#123;</span><br><span class="line">    [self jh_updateThemeByKey:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)jh_updateThemeByKey:(NSString *)key &#123;</span><br><span class="line">    [self jh_updateThemeByKey:key block:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)jh_updateThemeByKey:(NSString *)key</span><br><span class="line">                      block:(JHThemeCustomAction)block &#123;</span><br><span class="line">    [self jh_updateThemeByKey:key theme:nil block:block];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)jh_updateThemeByKey:(NSString *)key</span><br><span class="line">                      theme:(NSString *)theme</span><br><span class="line">                      block:(JHThemeCustomAction)block &#123;</span><br><span class="line">    [[JHThemeManager shareThemeManager] updateObjStyleWithCurrentTheme:self themeKey:key themeName:theme block:block];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>其实也只不过是对 <code>[[JHThemeManager shareThemeManager] updateObjStyleWithCurrentTheme:self themeKey:key themeName:theme block:block];</code> 的封装，这个key是配置里的 <code>key</code>，一般定义成类名。<code>theme</code> 就是主题的名字，传 <code>nil</code>的话就获取当前主题。然后创建在你的控制器基类、各种View的基类中合适的时机调用 <code>- (void)jh_updateTheme</code> 就会自动在生成时进行主题设置。</p>
<p>配置文件是这样的：<br><img src="/sunsx9316/APP%E5%88%87%E6%8D%A2%E4%B8%BB%E9%A2%98%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/img.jpg" alt="img"></p>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>实际使用中，这个轮子并不太方便。一是因为代码都在 <code>Plist</code> 里，不能非常直观的看到样式的设置过程。而且要求key与类中的属性，代码一旦有修改，<code>Plist</code>也需要做修改。最重要的一点是 <code>Value</code> 字符串的书写不能出错，但这是不太容易的，因为人就是个Bug。</p>
<p>比较好的解决方式就是写个GUI工具，能浏览和生成配置，而不是通过手工添加。</p>
</div></article></div></main><footer><div class="paginator"><a href="/sunsx9316/2018/08/26/iOS%E7%9A%84MobileVLCKit%E6%A1%86%E6%9E%B6%E6%92%AD%E6%94%BESMB%E5%8D%8F%E8%AE%AE%E8%A7%86%E9%A2%91%E7%9A%84%E9%97%AE%E9%A2%98/" class="prev">上一篇</a><a href="/sunsx9316/2018/08/26/UITableView-FDTemplateLayoutCell%E8%AE%A1%E7%AE%97%E8%A1%8C%E9%AB%98%E4%B8%80%E4%BA%9B%E7%BC%BA%E9%99%B7%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/" class="next">下一篇</a></div><div class="copyright"><p>© 2018 - 2021 <a href="https://github.com/sunsx9316">jimhuang</a> | Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>