<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 用更优雅的方式使用KVO · Jim Huang的博客</title><meta name="description" content="用更优雅的方式使用KVO - Jim Huang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://sunsx9316.github.io/atom.xml" title="Jim Huang的博客"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/sunsx9316" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">用更优雅的方式使用KVO</h1><div class="post-info">Aug 17, 2019</div><div class="post-content"><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在做项目的改造工作，发现了项目中用到了不少KVO，而且是通过字符串硬编码的方式书写，正所谓复制一时爽，重构火葬场，底层重构属性的时候这种字符串是不会给错误或者警告提示的，造成了排查的困难。以前个人使用过一个叫<code>libextobjc</code>的拓展库，里面有一些对keypath的封装，可以在编译期生成并且检查keypath，非常方便。</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>这部分KVO的拓展叫<code>EXTKeyPathCoding</code>，官方注释说支持两种写法。</p>
<ol>
<li><p><code>NSString *UTF8StringPath = @keypath(str.lowercaseString.UTF8String);
// =&gt; @&quot;lowercaseString.UTF8String&quot;</code></p>
</li>
<li><p><code>NSString *lowercaseStringPath = @keypath(NSString.new, lowercaseString);
// =&gt; @&quot;lowercaseString&quot;</code></p>
</li>
</ol>
<p>非常简洁明了，第一种比较直观，连续的点语法会截掉第一个<code>&quot;.&quot;</code>之前，保留之后的字符串。第二种只保留<code>&quot;,&quot;</code>后的字符串。值得一提的是对于类属性，也支持这种语法。比如这样：<br><code>NSString *versionPath = @keypath(NSObject, version);// =&gt; @&quot;version&quot;</code></p>
<p><strong>对于只是想了解用法的同学，下面的原理可以直接跳过，看最后的注意事项即可。</strong></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>近来有同事问起原理，于是深入研究了下，感叹作者对宏定义用法的炉火纯青，现在把过程分享出来。</p>
<p>先看源码，对于<code>@keypath</code>，主要的宏定义是这样写的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#define keypath(...) \</span><br><span class="line">    _Pragma(&quot;clang diagnostic push&quot;) \</span><br><span class="line">    _Pragma(&quot;clang diagnostic ignored \&quot;-Warc-repeated-use-of-weak\&quot;&quot;) \</span><br><span class="line">    (NO).boolValue ? ((NSString * _Nonnull)nil) : ((NSString * _Nonnull)@(cStringKeypath(__VA_ARGS__))) \</span><br><span class="line">    _Pragma(&quot;clang diagnostic pop&quot;) \</span><br><span class="line"></span><br><span class="line">#define cStringKeypath(...) \</span><br><span class="line">    metamacro_if_eq(1, metamacro_argcount(__VA_ARGS__))(keypath1(__VA_ARGS__))(keypath2(__VA_ARGS__))</span><br><span class="line"></span><br><span class="line">#define keypath1(PATH) \</span><br><span class="line">    (((void)(NO &amp;&amp; ((void)PATH, NO)), \</span><br><span class="line">    (&#123; char *__extobjckeypath__ = strchr(# PATH, &apos;.&apos;); NSCAssert(__extobjckeypath__, @&quot;Provided key path is invalid.&quot;); __extobjckeypath__ + 1; &#125;)))</span><br><span class="line"></span><br><span class="line">#define keypath2(OBJ, PATH) \</span><br><span class="line">    (((void)(NO &amp;&amp; ((void)OBJ.PATH, NO)), # PATH))</span><br></pre></td></tr></table></figure>
<p>看到的时候我的表情是黑人问号，幸好xcode有牛x闪闪的预处理功能，点击这里能看到：<br><img src="//sunsx9316.github.io/2019/08/17/用更优雅的方式使用KVO/1.png" alt="图片"></p>
<p>对于<code>@keypath(self.view)</code>展开后去掉断言等无关代码，核心代码变成了这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@(__objc_no).boolValue ? ((NSString * _Nonnull)((void *)0)) : </span><br><span class="line"></span><br><span class="line">((NSString * _Nonnull)@((((void)(__objc_no &amp;&amp; ((void)self.view, __objc_no)), </span><br><span class="line"></span><br><span class="line">(&#123; char *__extobjckeypath__ = strchr(&quot;self.view&quot;, &apos;.&apos;);  __extobjckeypath__ + 1; &#125;))) ));</span><br></pre></td></tr></table></figure>
<p>我们看到，这个宏定义就是一个三目运算符，接下来我们一步一步分析做了什么。</p>
<p>看第一行<code>@(__objc_no).boolValue ? ((NSString * _Nonnull)((void *)0))</code>，<code>__objc_no</code>就是<code>NO</code>，这里通过<code>@(NO)</code>将基本类型<code>NO</code>封装成了NSNumber。</p>
<p>而<code>((NSString * _Nonnull)((void *)0))</code>其实就是<code>((NSString * _Nonnull)nil)</code>。</p>
<p>所以这表达式简单写就是 <code>@(NO).boolValue ? nil : 巴拉巴拉</code>。或许你会疑惑这个三木运算符的意义何在，经过测试，移除掉没啥影响，我猜就是为了前面可以加一个酷炫的<code>@</code>符号吧。<code>RAC</code>里有<code>@weakify</code>这种写法也是要加<code>@</code>，其实也没什么用，就是为了酷炫，哈哈哈。</p>
<p>接下来我们看看第二行<code>((NSString * _Nonnull)@((((void)(__objc_no &amp;&amp; ((void)self.view, __objc_no))</code>，这句最大的意义其实就是提供了<code>self.view</code>让编译器能检查拼写。其实这里就是上面的<code>#define keypath1 (void)(NO &amp;&amp; ((void)PATH, NO))</code>展开的内容。这里用到了C语言里一些不太常用的写法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int c = (a, b)</span><br></pre></td></tr></table></figure>
<p>c最后的取值会是b。但是这样写编译器会报警告，简单的做法就是改成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int c = ((void)a, b)</span><br></pre></td></tr></table></figure>
<p>所以这里写void的原因你也理解了吧。</p>
<p>然后看最后一句：<code>({ char *__extobjckeypath__ = strchr(&quot;self.view&quot;, &#39;.&#39;);  __extobjckeypath__ + 1; })</code>。</p>
<p>这一句是由<code>keypath1</code>的后半部分展开而来。</p>
<p><code>strchr</code>是c语言中寻找一个字符在另一个字符串中第一次出现的位置的函数，找到会返回位置的指针，没找到返回<code>NULL</code>。具体到这里，就是找到<code>&#39;.&#39;</code>在<code>&quot;self.view&quot;</code>中第一次出现的位置。这里+1相当于截断了<code>&#39;.&#39;</code>之前包括<code>&#39;.&#39;</code>的内容，所以能理解为什么它能找到对应的<code>keypath</code>了吧。<code>{()}</code>也是一个语法糖，会把最后一行做为表达式的返回值。好处就是在大括号中有自己的局部变量作用域，在临时变量很多，难以管理的时候这种写法可以比较优雅的解决问题。常见的写法像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSArray *arr = (&#123;</span><br><span class="line">        NSMutableArray *mArr = [NSMutableArray array];</span><br><span class="line">        [mArr addObject:@(123)];</span><br><span class="line">        mArr;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>最后arr的取值会是mArr，不需要写return。</p>
<p>最后我们看到，返回值被<code>@()</code>包住，这是什么语法？我们知道<code>@(123)</code>这个语法糖会生成NSNumber，而比较少见的<code>@(&quot;123&quot;)</code>则会生成<code>NSString</code>。这里的<code>char *__extobjckeypath__</code>就是一个c的字符串，所以你理解为什么最后能生成了一个<code>NSString</code>了吧。</p>
<p>讲到这里我们梳理完了第一种<code>keypath</code>的写法，第二种写法原理大致相同，在宏定义中 <code># 变量名</code>的写法会直接转换成c字符串，这就是第二种写法会把<code>,</code>之后的内容转换成字符串的基础。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们可以看到作者对宏定义的运用到了非常高的水平，如果感兴趣，还可以阅读开源库里其它模块的代码，很值得研究。</p>
<p>说一下注意点，有同事在写<code>keypath</code>的时候写过类似这样的代码：</p>
<p><code>@keypath(XXManager.shareManager.abc)</code>，编译没有任何问题，跑起来却crash了，报错是<code>xxx was sent to an object that is not KVC-compliant for the &quot;shareManager&quot; property.</code>为什么？</p>
<p>其实不是这个库的锅，因为<code>shareManager</code>是个类属性，它的<code>get</code>方法本质其实是个类方法，而只有实例属性才支持KVO，所以一定要小心。改法也很简单，使用第二种写法就行<code>@keypath(FTManager.shareManager, abc)</code></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.sunnyxx.com/2014/03/06/rac_1_macros/" target="_blank" rel="noopener">Reactive Cocoa Tutorial [1] = 神奇的Macros</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/03/31/Flutter学习笔记(一)/" class="next">NEXT</a></div><div class="copyright"><p>© 2018 - 2019 <a href="https://sunsx9316.github.io">Jim Huang</a> | Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>