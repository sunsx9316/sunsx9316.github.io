{"meta":{"title":"Jim Huang的博客","subtitle":null,"description":null,"author":"Jim Huang","url":"https://github.com/sunsx9316"},"pages":[],"posts":[{"title":"APP切换主题的一些思考","slug":"APP切换主题的一些思考","date":"2018-08-26T07:14:17.000Z","updated":"2018-09-07T16:51:47.159Z","comments":true,"path":"2018/08/26/APP切换主题的一些思考/","link":"","permalink":"https://github.com/sunsx9316/2018/08/26/APP切换主题的一些思考/","excerpt":"","text":"前言APP内切换主题是比较常见的需要，蛮早就思考过这个问题。网上也有很多的解决方案，不过本质上其实都类似，无非是两种情况。 如果需要实现类似手Q那样动态更换主题，那么主题一定是个配置文件，能够从服务器下载。 如果只要求能更换成本地的几套主题，那只通过代码初始化，写死也是可以的。 说说两者的优缺点。 第一种比较灵活，但是引入的配置文件肯定要求格式的通用，毕竟不太可能要求服务端针对不同的设备提供不同的配置。那么很多人或许会选择JSON或者XML之类的格式。这样就会导致可读性不那么好，也不太直观，而且也没办法在编译期就做代码检查。 第二种对比第一种就更直观，没有什么能比 label.textColor = redColor 这样的代码更易读了吧。同时因为是原生开发，也可以在编译期就做到代码检查，缺点就是灵活性差了些。 所以要做的其实是选择适合自己的类型，还有如何能更简单的做到切换而已。这个轮子其实并不太适合项目，更多是作为思考。公司项目并不要求做到类似手Q那样动态切换主题，但是为了拓展性，我还是考虑通过配置文件去加载。 目的因为写主题配置是十分麻烦的事，我想要做到的效果是只写配置文件，代码里不需要写任何判断和设置的逻辑就能做到自动根据当前主题切换样式。所以要做的事分为以下几步： 书写配置 程序读取配置 代码根据当前主题自动设置样式 同时配置文件要求可读性良好，就算别人接手了这个模块也不需要熟悉特定的配置书写语法。 实现配置文件因为是本地使用，那么可以不考虑通用性，为了开发简单，我们使用Plist写配置。为了可读性良好，且尽量不增加学习成本，我想做到最好写在配置里的就是类似 label.textColor = redColor 这样的赋值语句。那能不能做到这一点呢，当然可以，我们可以借助OC的KVC。KVC本身也支持keyPath这样的赋值方式，&quot;label.textColor&quot; 这样的字符串在KVC中会被解析成查找 label 下的 textColor 属性。所以我们在 Plist \b里的 key就可以定义成 &quot;label.textColor&quot;，而 value就是颜色。 那么问题来了，Plist 只支持字符串、数字、日期、二进制流这几种有限的格式，那怎么让它支持颜色呢？很容易联想到颜色16进制的表示方式，比如白色使用16进制表示就是 #FFFFFF，所以直接使用字符串不就好了。但是问题没这么简单。 一种比较常见的需求是在不同的主题下需要显示不同图片 (比如我们就有白天和黑夜模式，黑夜模式的图片就要求暗一些。小声bb……)，颜色如果使用了 #FFFFFF 这样的方式设置，那么图片怎么办？图片可以根据图片名，但是程序需要知道这个字符串是什么才能把它转成对应的东西，所以就需要定一套简单的规则了。 字符串非常灵活，任意的组合可以得到完全不同的内容，所以对于这种情况，选择字符串类型是比较合适的。类似编译器，有一套自己的复杂的解析规则，会把字符串转换为语法树。我们不需要这么复杂，只是简单的格式就好，但是可以设计成拥有很强拓展性的模式。所以我们需要定义一些通用的接口，生成一些解析器，这会在第二步详细说明。 读取配置这一步比较重要的是接口的设计，关乎到使用的方便性和未来的拓展性。 我们接着说第一步末尾说到的解析器。为什么要定义解析器呢？首先每一个 Plist的对象，值传过来都是个字符串，我们要根据里面字符串的格式判断它是应该解析成颜色，或者图片又或者是其它。每种情况都不一样，所以拆分成独立的解析器会更好。不过他们都用一个共同点，遵守同一个协议。协议我们这样定义： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** 解析优先级 - JHThemeParserPriorityRequest: 最先解析 - JHThemeParserPriorityNormal: 普通 - JHThemeParserPriorityUnimportance: 最后解析 */typedef NS_ENUM(NSUInteger, JHThemeParserPriority) &#123; JHThemeParserPriorityUnimportance, JHThemeParserPriorityNormal, JHThemeParserPriorityRequest = 1000,&#125;;@class JHTheme;@protocol JHThemeParserProtocol &lt;NSObject&gt;/** 解析优先级 */@property (nonatomic, assign, readonly) JHThemeParserPriority priority;/** 唯一标识 */@property (nonatomic, copy, readonly) NSString *identify;/** 是否在解析之后直接返回 YES会将解析结果让之后的解析器继续解析 */@property (nonatomic, assign, readonly) BOOL continueParse;/** 是否能解析这个值 @param value 值 @return 是否能解析这个值 */- (BOOL)canParseValue:(id)value;/** 解析具体实现 @param value 值 @param currentTheme 当前主题 @return 解析结果 */- (id)converValue:(id)value currentTheme:(JHTheme *)currentTheme;@end 重要的是这两个方法：12- (BOOL)canParseValue:(id)value;- (id)converValue:(id)value currentTheme:(JHTheme *)currentTheme; 第一个方法判断这个解析器能否解析这个字符串。 如果返回 true ， 那么会接着调用converValue:(id)value currentTheme:(JHTheme *)currentTheme，让解析器自己内部进行解析。 如果返回 false，那么这个解析器就无法解析这个字符串，也不会有之后的调用了。 举个简单的例子，这是颜色解析器内部的实现：123456789101112131415161718192021222324252627282930@implementation JHThemeColorParser- (BOOL)canParseValue:(NSString *)value &#123; if ([value isKindOfClass:[NSString class]] &amp;&amp; ([value hasPrefix:@&quot;c(&quot;] || [value hasPrefix:@&quot;C(&quot;]) &amp;&amp; [value hasSuffix:@&quot;)&quot;]) &#123; return YES; &#125; return NO;&#125;- (id)converValue:(NSString *)value currentTheme:(JHTheme *)currentTheme &#123; //取出色值 value = [value substringWithRange:NSMakeRange(2, value.length - 3)]; NSArray &lt;NSString *&gt;*rgba = [value componentsSeparatedByString:@&quot;,&quot;]; //16进制 if (rgba.count == 1) &#123; return [UIColor colorWithHexString:value]; &#125; else if (rgba.count &gt;= 3) &#123; CGFloat r = 0,g = 0,b = 0,a = 1; r = rgba.firstObject.doubleValue / 255.0; g = rgba[1].doubleValue / 255.0; b = rgba[2].doubleValue / 255.0; if (rgba.count &gt;= 4) &#123; a = rgba[3].doubleValue; &#125; return [UIColor colorWithRed:r green:g blue:b alpha:a]; &#125; return value;&#125;@end 首先 - (BOOL)canParseValue:(id)value 这个方法的实现是判断值是否符合规则，这里我定义成符合 c(#FFFFF) 或者 c(255,255,255) 格式的字符串就可以解析。前者是颜色的16进制表示法，后者是通过指定RGB数字的颜色表示法。而下面只是对这个解析格式的实现而已。这样做的好处是如果想定义一套比较复杂的解析规则，只要实现协议，自己写解析逻辑就好了。比如除了颜色的，我还实现了一些类似宏的解析逻辑。像这样： 123456789101112131415161718192021222324- (BOOL)canParseValue:(NSString *)value &#123; if ([value isKindOfClass:[NSString class]] &amp;&amp; ([value hasPrefix:@&quot;d(&quot;] || [value hasPrefix:@&quot;D(&quot;]) &amp;&amp; [value hasSuffix:@&quot;)&quot;]) &#123; return YES; &#125; return NO;&#125;- (id)converValue:(NSString *)value currentTheme:(JHTheme *)currentTheme &#123; NSString *tempStr = [[value substringWithRange:NSMakeRange(2, value.length - 3)] stringByTrim]; NSDictionary *mapDic = currentTheme.defineMap; id map = mapDic[tempStr]; if (map) &#123; return map; &#125; return value;&#125;- (BOOL)continueParse &#123; return YES;&#125;- (JHThemeParserPriority)priority &#123; return JHThemeParserPriorityRequest;&#125; 场景是APP有一个主题色，如果按照上面只是通过指定颜色去写，那就会很麻烦，而且一旦主题色更换，也要全局修改。这个宏解析器就定义了一种字符串格式像这样 d(mainColor)。配置文件有一个独立的”宏字典”，解析器取出 mainColor 然后在”宏字典”里查找 mainColor对应的 value是什么，这个 value 我只要定义成c(#FFFFF) 或者其它解析器可以解析的格式，就可以做到类似宏定义的替换效果。需要注意的是 - (BOOL)continueParse 需要返回 YES，这样解析的结果才能返回给其它的解析器继续解析。 所以可以看到，这样是非常灵活的。 自动设置样式这一步其实相对来说比较容易了，但是也有不少值得说的地方。我这里定义了一个叫 themeManager 的主题管理类。接口这样设计： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** 自定义操作block @param aObj 更改的对象 @param key 键 @param value 值 @return 自定义更改的对象 */typedef id(^JHThemeCustomAction)(id aObj, NSString *key, id value);@class JHThemeManager;@protocol JHThemeManagerObserver&lt;NSObject&gt;@optional//主题改变回调- (void)themeManager:(JHThemeManager *)themeManager didChangeTheme:(JHTheme *)theme;@end@interface JHThemeManager : NSObject+ (instancetype)shareThemeManager;@property (nonatomic, strong, readonly) JHTheme *currentTheme;/** 注册自定义解析器 @param parserClass 解析器需要实现 JHThemeParserProtocol接口 */- (void)registerParser:(Class)parserClass;/** 添加单个主题 @param theme 主题对象 */- (void)addTheme:(JHTheme *)theme;/** 添加多个主题 @param themes 主题数组 */- (void)addThemes:(NSArray &lt;JHTheme *&gt;*)themes;/** 根据主题名称更改当前主题 @param themeName 主题名称 */- (void)updateThemeByName:(NSString *)themeName;/** 根据当前主题更新对象的样式 @param obj 对象 @param themeKey 主题下的Key 空则为obj的类名 @param block 自定义操作 */- (void)updateObjStyleWithCurrentTheme:(id)obj themeKey:(NSString *)themeKey block:(JHThemeCustomAction)block;/** 根据当前主题更新对象的样式 @param obj 对象 @param themeKey 主题下的Key 空则为obj的类名 @param themeName 主题名称 @param block 自定义操作 */- (void)updateObjStyleWithCurrentTheme:(id)obj themeKey:(NSString *)themeKey themeName:(NSString *)themeName block:(JHThemeCustomAction)block;- (void)addObserver:(id&lt;JHThemeManagerObserver&gt;)observer;- (void)removeObserver:(id&lt;JHThemeManagerObserver&gt;)observer;@end - (void)registerParser:(Class)parserClass 注册的是遵守了解析器协议的类，只有注册了才支持解析这种类型的字符串。内部实现是通过数组保存示例，解析的时候根据优先级循环调用已经注册的解析器进行解析。 然后重点是自动。因为我们的 key 是 keyPath的形式，所以直接通过KVC把解析结果赋值就行。 实现如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208- (void)updateObjStyleWithCurrentTheme:(id)toObj themeKey:(NSString *)themeKey themeName:(NSString *)themeName block:(JHThemeCustomAction)block &#123; if (toObj == nil) return; if (themeKey.length == 0) &#123; themeKey = NSStringFromClass([toObj class]); &#125; JHTheme *aTheme = nil; if (themeName.length == 0) &#123; aTheme = self.currentTheme; &#125; else &#123; aTheme = [self themeByName:themeName]; &#125; //获取当前主题所有存储的内容 NSDictionary *content = aTheme.content[themeKey]; if ([content isKindOfClass:[NSDictionary class]] == NO) return; [content enumerateKeysAndObjectsUsingBlock:^(NSString * _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123; //自定义修改 if (block) &#123; obj = block(toObj, key, [self converValueWithObj:obj]); if (obj == nil) return; &#125; NSString *cacheKey = [themeKey stringByAppendingFormat:@&quot;.%@&quot;, key]; NSNumber *cache = [self.keyPathCache objectForKey:cacheKey]; //没有缓存过 if (cache == nil) &#123; NSArray &lt;NSString *&gt;*keyPaths = [key componentsSeparatedByString:@&quot;.&quot;]; id lastObj = toObj; //单个key if (keyPaths.count == 1) &#123; //当前key不存在 BOOL exist = [lastObj respondsToSelector:NSSelectorFromString(keyPaths.firstObject)]; NSAssert(exist, @&quot;%@不存在 设置主题失败&quot;, key); if (exist == false) &#123; cache = @(NO); [self.keyPathCache setObject:cache forKey:cacheKey]; return; &#125; else &#123; cache = @(YES); [self.keyPathCache setObject:cache forKey:cacheKey]; &#125; &#125; //keyPath else &#123; BOOL flag = YES; for (NSInteger i = 0; i &lt; keyPaths.count - 1; ++i) &#123; NSString *key = keyPaths[i]; SEL selector = NSSelectorFromString(key); if ([lastObj respondsToSelector:selector]) &#123; lastObj = [lastObj valueForKey:key]; &#125; else &#123; flag = NO; break; &#125; &#125; if (flag) &#123; flag = [lastObj respondsToSelector:NSSelectorFromString(keyPaths.lastObject)]; &#125; cache = @(flag); [self.keyPathCache setObject:cache forKey:cacheKey]; if (flag == NO) &#123; NSLog(@&quot;%@不存在 设置主题失败&quot;, key); return; &#125; &#125; &#125; //key无效 if (cache.boolValue == NO) return; //多参数 if ([key containsString:@&quot;:&quot;]) &#123; NSArray *separatedValues = [key componentsSeparatedByString:@&quot;.&quot;]; NSString *method = separatedValues.lastObject; SEL aSEL = NSSelectorFromString(method); //真正发消息的对象 id sendObj = [toObj valueForKeyPath:[key stringByReplacingOccurrencesOfString:[NSString stringWithFormat:@&quot;.%@&quot;, method] withString:@&quot;&quot;]]; NSArray *valueArr = [obj isKindOfClass:[NSArray class]] ? obj : @[obj]; YYClassMethodInfo *info = [[YYClassMethodInfo alloc] initWithMethod:class_getInstanceMethod([sendObj class], aSEL)]; //冒号之后的参数为实际参数 NSArray &lt;NSString *&gt;*argumentTypeEncodings = ^&#123; NSInteger index = [info.argumentTypeEncodings indexOfObject:@&quot;:&quot;]; if (index != NSNotFound) &#123; return (NSArray *)[info.argumentTypeEncodings subarrayWithRange:NSMakeRange(index + 1, info.argumentTypeEncodings.count - index - 1)]; &#125; return @[]; &#125;(); //参数个数和key的方法不一致 if (argumentTypeEncodings.count != valueArr.count) &#123; return; &#125; NSMethodSignature *sign = [sendObj methodSignatureForSelector:aSEL]; NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:sign]; invocation.target = sendObj; invocation.selector = aSEL; for (NSInteger idx1 = 0; idx1 &lt; argumentTypeEncodings.count; ++idx1) &#123; id obj1 = valueArr[idx1]; id tempObj = [self converValueWithObj:obj1]; YYEncodingType encodingType = YYEncodingGetType(argumentTypeEncodings[idx1].UTF8String); switch (encodingType) &#123; case YYEncodingTypeBool: &#123; BOOL aValue = [tempObj boolValue]; [invocation setArgument:&amp;aValue atIndex:idx1 + 2]; &#125; break; case YYEncodingTypeInt8: &#123; char aValue = [tempObj charValue]; [invocation setArgument:&amp;aValue atIndex:idx1 + 2]; &#125; break; case YYEncodingTypeUInt8: &#123; unsigned char aValue = [tempObj unsignedCharValue]; [invocation setArgument:&amp;aValue atIndex:idx1 + 2]; &#125; break; case YYEncodingTypeInt16: &#123; short aValue = [tempObj shortValue]; [invocation setArgument:&amp;aValue atIndex:idx1 + 2]; &#125; break; case YYEncodingTypeUInt16: &#123; unsigned short aValue = [tempObj unsignedShortValue]; [invocation setArgument:&amp;aValue atIndex:idx1 + 2]; &#125; break; case YYEncodingTypeInt32: &#123; int32_t aValue = [tempObj intValue]; [invocation setArgument:&amp;aValue atIndex:idx1 + 2]; &#125; break; case YYEncodingTypeUInt32: &#123; uint32_t aValue = [tempObj intValue]; [invocation setArgument:&amp;aValue atIndex:idx1 + 2]; &#125; break; case YYEncodingTypeInt64: &#123; long long aValue = [tempObj longLongValue]; [invocation setArgument:&amp;aValue atIndex:idx1 + 2]; &#125; break; case YYEncodingTypeUInt64: &#123; unsigned long long aValue = [tempObj unsignedLongLongValue]; [invocation setArgument:&amp;aValue atIndex:idx1 + 2]; &#125; break; case YYEncodingTypeFloat: &#123; float aValue = [tempObj floatValue]; [invocation setArgument:&amp;aValue atIndex:idx1 + 2]; &#125; break; case YYEncodingTypeDouble: &#123; double aValue = [tempObj doubleValue]; [invocation setArgument:&amp;aValue atIndex:idx1 + 2]; &#125; break; case YYEncodingTypeLongDouble: &#123; long double aValue = [tempObj doubleValue]; [invocation setArgument:&amp;aValue atIndex:idx1 + 2]; &#125; break; case YYEncodingTypeObject: &#123; [invocation setArgument:&amp;tempObj atIndex:idx1 + 2]; &#125; break; default: break; &#125; &#125; //调用 [invocation invoke]; &#125; else &#123; [toObj setValue:[self converValueWithObj:obj] forKeyPath:key]; &#125; &#125;];&#125; 这么长一段代码，我都不想看😑，幸好还记得怎么实现的。按照上面我们说的，应该非常简单才对，但是实际上还要处理一些其他情况。举个例子，UIButton 在设置图片、文字颜色等属性的时候需要带上 UIControlState，那就需要传两个参数。Plist可以把这种多参数保存为数组，但是KVC就没办法做到赋值了，这时候就要借助到OC的运行时了。 我们知道，OC\b的方法调用，本质都是发送消息，而消息的参数是不确定的，所以我们可以借助底层提供的 NSInvocation 这种通过方法签名发消息的类。如果了解过OC的消息转发机制的同学，应该见过这个类。它其实是一个调用器，设置了方法签名，再设置了参数就可以像普通消息发送了。方法名我们定义成配置的 key，多参数就和OC的方法名一样，用”:”隔开，类似这样：setImage:forState，value 是一个数组。实现用了YYKit的一些方法，只是写起来简单一些，内部就是调用runtime的API，这样就做到了多参数的兼容。 然而实际使用的时候，其实很麻烦。有一个比较巧妙的方式是通过分类去添加参数。比如 UIButton 的 setImage:forState，我们可以添加这些分类：123@property (nonatomic, strong) UIImage *jh_normalImg;@property (nonatomic, strong) UIImage *jh_hightlightedImg;... 实现是这样：123456789101112131415- (void)setJh_normalImg:(UIImage *)jh_normalImg &#123; [self setImage:jh_normalImg forState:UIControlStateNormal];&#125;- (UIImage *)jh_normalImg &#123; return [self imageForState:UIControlStateNormal];&#125;- (void)setJh_hightlightedImg:(UIImage *)jh_hightlightedImg &#123; [self setImage:jh_hightlightedImg forState:UIControlStateHighlighted];&#125;- (UIImage *)jh_hightlightedImg &#123; return [self imageForState:UIControlStateHighlighted];&#125; 通过分类指定其它的参数就可以像单个参数那样使用了。 至于自动调用，其实很简单。我们给 NSObject 添加一个分类，实现如下：12345678910111213141516171819202122@implementation NSObject (JHThemeManager)- (void)jh_updateTheme &#123; [self jh_updateThemeByKey:nil];&#125;- (void)jh_updateThemeByKey:(NSString *)key &#123; [self jh_updateThemeByKey:key block:nil];&#125;- (void)jh_updateThemeByKey:(NSString *)key block:(JHThemeCustomAction)block &#123; [self jh_updateThemeByKey:key theme:nil block:block];&#125;- (void)jh_updateThemeByKey:(NSString *)key theme:(NSString *)theme block:(JHThemeCustomAction)block &#123; [[JHThemeManager shareThemeManager] updateObjStyleWithCurrentTheme:self themeKey:key themeName:theme block:block];&#125;@end 其实也只不过是对 [[JHThemeManager shareThemeManager] updateObjStyleWithCurrentTheme:self themeKey:key themeName:theme block:block]; 的封装，这个key\b是配置里的 key，一般定义成类名。theme 就是主题的名字，传 nil的话就获取当前主题。然后创建在你的控制器基类、各种View的基类中合适的时机调用 - (void)jh_updateTheme 就会自动在生成时进行主题设置。 配置文件是这样的： 结尾实际使用中，这个轮子并不太方便。一是因为代码都在 Plist 里，\b不能非常直观的看到样式的设置过程。而且要求key与类中的属性，代码一旦有修改，Plist也需要做修改。最重要的一点是 Value 字符串的书写不能出错，但这是不太容易的，因为人就是个Bug。 比较好的解决方式就是写个GUI工具，能浏览和生成配置，而不是通过手工添加。","categories":[],"tags":[]},{"title":"UITableView+FDTemplateLayoutCell计算行高一些缺陷的解决方法","slug":"UITableView-FDTemplateLayoutCell计算行高一些缺陷的解决方法","date":"2018-08-25T18:27:38.000Z","updated":"2018-09-07T16:50:41.798Z","comments":true,"path":"2018/08/26/UITableView-FDTemplateLayoutCell计算行高一些缺陷的解决方法/","link":"","permalink":"https://github.com/sunsx9316/2018/08/26/UITableView-FDTemplateLayoutCell计算行高一些缺陷的解决方法/","excerpt":"","text":"前言UITableView动态行高一直是iOS的一个经典问题，在没有AutoLayout的时代，只能自己计算frame，然后返回给代理，非常痛苦。到了AutoLayout的时代，布局就变得简单多了，甚至于通过系统提供的API都能自动计算出行高。 UITableView+FDTemplateLayoutCell就是sunnyxx大大的一个自动计算行高的框架。只要布局正确，通过它可以自动计算并缓存行高，非常方便。不过在使用上发现一些问题，也尝试去解决了。 过程需求是这样的，一个类似微博的页面，像这样： 这应该是比较经典的布局，内容和图片都是不确定的，行高要根据实际数据计算。九宫格实现方式有很多，我这里是通过UICollectionView去实现的。这样的一个好处就是UICollectionView的高度可以通过它的collectionViewLayout对象获取，啥都不用算。不过会有一个问题，UICollectionView继承自UIScrollView，它的高度没法按照内容来全显示。所以即使布局正确，通过AutoLayout来计算行高也是不包括UICollectionView的，这个问题同样反映在一些UIView控件上。 这就十分蛋疼了，难道还要回到手算frame的时代？当然不是，是我还写啥博客。 我说下解决的几个方法。 方法一（不推荐）：手动设置collectionView的高度，可以通过代码或者xib来设置，我这里是xib。 像这样手动指定collectionView的高度，然后赋值数据源的时候更新collectionView高度约束就可以了，让它的高度等于它的contentSize.height，这样就能全部显示了，其它UIView控件也能这么解决。但是这样在计算行高的时候会抛出非常多异常，都是约束的问题。我不是很清楚这是什么原因，按理说计算再后，赋值在前，应该不会这样。而且显示会出一些问题，计算的行高会不正确，有些许误差。 方法二（推荐）：既然不能通过这种方式，那就绕个弯吧。去掉高度约束，计算出来的高就不包含collectionView的高。然后再手动加上collectionView的高返回给代理不就行了。不过看下UITableView+FDTemplateLayoutCell的拓展方法：12- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifierconfiguration:(void (^)(id cell))configuration; 只有一个设置cell数据源的block，正常情况下我们只需要把cell换成我们自己的类，然后赋值模型就行，缓存之类的框架会自动处理好。虽然我们可以获取到缓存高度之后再加上collectionView的高，但是这样还叫啥缓存，缓存就是不需要计算，直接取到就能用，那怎么办呢？虽然可以通过Method Swizzling黑魔法交换方法实现，但是这并不是最优方法，往往是一些莫名其妙的bug的源泉，作为开发者应该尽量避免这种方式。所以最后我选择了通过分类的方式。思路是在框架计算完高度之后通过block返回，我们自行处理行高，加加减减，然后返回高度让框架缓存。具体代码：我们参考下框架这个方法的实现1234567891011121314151617181920- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifiercacheByIndexPath:(NSIndexPath *)indexPathconfiguration:(void (^)(id cell))configuration &#123;if (!identifier || !indexPath) &#123;return 0;&#125;//命中缓存if ([self.fd_indexPathHeightCache existsHeightAtIndexPath:indexPath]) &#123;[self fd_debugLog:[NSString stringWithFormat:@&quot;hit cache by index path[%@:%@] - %@&quot;, @(indexPath.section), @(indexPath.row), @([self.fd_indexPathHeightCache heightForIndexPath:indexPath])]];return [self.fd_indexPathHeightCache heightForIndexPath:indexPath];&#125;//计算行高CGFloat height = [self fd_heightForCellWithIdentifier:identifier configuration:configuration];[self.fd_indexPathHeightCache cacheHeight:height byIndexPath:indexPath];[self fd_debugLog:[NSString stringWithFormat: @&quot;cached by index path[%@:%@] - %@&quot;, @(indexPath.section), @(indexPath.row), @(height)]];return height;&#125; 它先从缓存中寻找行高，命中之后直接返回。否则计算行高，存入缓存，然后返回。所以很简单，我们可以直接复制它的代码。写一个带编辑行高功能的方法：12345678910111213141516171819202122232425262728293031typedef CGFloat(^editCellHeightAction)(id cell, CGFloat cellHeight);- (CGFloat)jh_heightForCellWithIdentifier:(NSString *)identifiercacheByIndexPath:(NSIndexPath *)indexPathconfiguration:(void (^)(id cell))configurationeditAction:(editCellHeightAction)editAction &#123;if (!identifier || !indexPath) &#123;return 0;&#125;// Hit cacheif ([self.fd_indexPathHeightCache existsHeightAtIndexPath:indexPath]) &#123;[self fd_debugLog:[NSString stringWithFormat:@&quot;hit cache by index path[%@:%@] - %@&quot;, @(indexPath.section), @(indexPath.row), @([self.fd_indexPathHeightCache heightForIndexPath:indexPath])]];return [self.fd_indexPathHeightCache heightForIndexPath:indexPath];&#125;CGFloat height = 0;//获取缓存中的cellUITableViewCell *templateLayoutCell = [self fd_templateCellForReuseIdentifier:identifier];//这里插入编辑行高的代码if (editAction) &#123;height = editAction(templateLayoutCell, [self fd_heightForCellWithIdentifier:identifier configuration:configuration]);&#125;else &#123;height = [self fd_heightForCellWithIdentifier:identifier configuration:configuration];&#125;[self.fd_indexPathHeightCache cacheHeight:height byIndexPath:indexPath];[self fd_debugLog:[NSString stringWithFormat: @&quot;cached by index path[%@:%@] - %@&quot;, @(indexPath.section), @(indexPath.row), @(height)]];return height;&#125;&#125; 使用起来像这样：1234567891011- (CGFloat)tableView:(UITableView *)tableViewheightForRowAtIndexPath:(NSIndexPath *)indexPath &#123;return [tableView jh_heightForCellWithIdentifier:@&quot;MineCell&quot; cacheByIndexPath:indexPath configuration:^(HeSquareCell *cell) &#123;//正常赋值数据源cell.model = self.model;&#125; editAction:^CGFloat(MineCell *cell, CGFloat cellHeight) &#123;//cellHeight是上面的block计算后回调过来的 所以直接加上额外的高度即可//因为缓存的关系这里只会走一次 所以可以放心写return cellHeight + [cell collectionViewHeightWithModel:self.model];&#125;];&#125; 这样高度就能正常显示了，而且也不会抛异常，还能享受框架带来的便利。UITableView+FDTemplateLayoutCell的接口设计很易于拓展，所以写起来很简单。还有个问题，我发现在使用这个框架的时候，如果_tableView.tableFooterView = [[UIView alloc] init];这句话写在注册cell之前，程序会crash，不造为啥。如果各位有更好的解决思路或者文中有错误的地方欢迎给我留言。","categories":[],"tags":[]},{"title":"iOS的MobileVLCKit框架播放SMB协议视频的问题","slug":"iOS的MobileVLCKit框架播放SMB协议视频的问题","date":"2018-08-25T16:57:02.854Z","updated":"2018-08-26T10:46:38.209Z","comments":true,"path":"2018/08/26/iOS的MobileVLCKit框架播放SMB协议视频的问题/","link":"","permalink":"https://github.com/sunsx9316/2018/08/26/iOS的MobileVLCKit框架播放SMB协议视频的问题/","excerpt":"","text":"MobileVLCKit是开源播放器VLC的iOS平台框架，在Mac OS上也有对应的VLCKit，搞直播的同学应该不陌生，不过它其实还是一款强大的本地播放器，支持几乎所有的主流媒体格式。最近在研究app如何浏览电脑上文件，然后直接做到播放视频的功能。用过iOS上的VLC播放器的童鞋应该知道，他能做到扫描本地端口，然后通过输入用户名和密码浏览电脑的文件，点击视频和音频还能直接播放。通过Google知道这里用到一个叫SMB的协议，不光是Mac OS上，Windows和Linux都支持这种协议。只要本地开启SMB的文件共享服务，同一个局域网内的设备就能通过它访问电脑上的文件了。上上gayhub发现了一个SMB的iOS框架，叫TOSMBClient，它将一个C语言的框架封装成了OC的框架。还支持CocoaPods，使用起来非常方便。而MobileVLCKit原生就支持SMB协议的在线播放。所以解决方案是通过TOSMBClient获取文件列表，VLC播放，想法很美好，但是实际实现还是踩了不少坑。 先说说SMB的格式，长这样：smb://{hostname}:{password}@{ip}/path 比如桌面上的一个mp4文件就应该长这样：smb://xiaoming:123456@192.168.1.100/xiaoming/Desktop/233.mp4hostname是域名，一般创建SMB共享协议的时候，就需要指定。password是密码，ip是服务器的ip。TOSMBClient提供了一个登录的类叫TOSMBSession，常用属性是这几个12345678//服务器域名@property (nonatomic, copy) NSString *hostName;//服务器ip@property (nonatomic, copy) NSString *ipAddress;//登录的用户名@property (nonatomic, copy) NSString *userName;//登录密码@property (nonatomic, copy) NSString *password; 其中域名和ip可以都设置，也可以只设置其中一个，框架会自动查找。然后通过TOSMBSession提供的方法123- (void)requestContentsOfDirectoryAtFilePath:(NSString *)pathsuccess:(void (^)(NSArray *files))successHandler error:(void (^)(NSError *))errorHandler; 获取文件列表，很简单。返回的files是TOSMBSessionFile类型。它包含基本的文件信息，比如路径，名称，大小。想法挺美好，有URL，直接给VLC播放不就行了，然后就碰到了第一个坑。TOSMBSessionFile提供的路径只是smb格式的一部分，也就只有path部分，所以需要播放还得自己拼接成完整路径。 拼接好了之后尝试下播放个文件，没带中文的，成功了，高兴之余本着严谨的态度试了下中文路径，结果失败了。NSURL初始化如果包含标准ASCALL以外的字符，会返回nil，这是第二个坑。 作为程序员，很自然会想到，URL如果带中文，浏览器会自动做URL转码。\b所以尝试下转码，发现还是播放失败。这就让我怀疑人生了，怎么肥事？而且连iOS上的VLC的app都有这个问题，这是第三个坑。 通过查找API我发现播放器除了通过NSURL初始化，还可以通过NSString初始化，我想，NSURL不让包含中文，NSString总可以吧。结果还是播放失败，神奇的是即使不包含中文，通过NSString初始化还是失败，但是NSURL就可以，这是第四个坑。 既然一定要实现功能，那就得搞明白为什么，这时候开源的好处就体现出来了，我看了下MobileVLCKit的源码，它的媒体类VLCMedia是这么写的：123456789101112131415161718192021222324252627- (instancetype)initWithPath:(NSString *)aPath&#123; return [self initWithURL:[NSURL fileURLWithPath:aPath isDirectory:NO]];&#125;- (instancetype)initWithURL:(NSURL *)anURL&#123; if (self = [super init]) &#123; const char *url; VLCLibrary *library = [VLCLibrary sharedLibrary]; NSAssert(library.instance, @&quot;no library instance when creating media&quot;); if (([[anURL absoluteString] hasPrefix:@&quot;sftp://&quot;]) || ([[anURL absoluteString] hasPrefix:@&quot;smb://&quot;])) &#123; url = [[[anURL absoluteString] stringByRemovingPercentEncoding] UTF8String]; &#125; else &#123; url = [[anURL absoluteString] UTF8String]; &#125; p_md = libvlc_media_new_location(library.instance, url); _metaDictionary = [[NSMutableDictionary alloc] initWithCapacity:3]; [self initInternalMediaDescriptor]; &#125; return self;&#125; 可以看到，initWithPath:方法把字符串通过fileURLWithPath:isDirectory:方法初始化成URL了，所以smb格式的字符串路径通过这个方法初始化得到的路径肯定是错的，因为它不是标准的本地路径，自然会出现上面神奇的情况。然后看下initWithURL:方法，if语句判断如果包含smb前缀，则做URL解码操作。说明我们的想法是正确的，确实应该对URL进行编码。但是，经过测试编码还是不行，这种情况就很费解了。到现在我还不知道什么原因，因为它自己的APP都有这个问题。不过之后偶然发现了解决方法，很简单把URL编码两次即可！！把URL编码两次即可！！把URL编码两次即可！！ 重要的事情说三遍，编码两次之后框架会对URL解码一次，所以得到的URL实际是编码了一次的内容，这样就能播放了，非常神奇，这是第五个坑。在这里分享一下给需要的童鞋。 注意事项应该只对path、hostname、password部分做URL两次编码，smb://前缀不需要，否则播放器会无法识别。 2017.10.16日更新 如果发现拼接之后还是没法播放，大部分是因为VLC的版本比较旧的关系，cocoapods里有最新的unstable版本，用这个，不过这个版本也是最不稳定的。 2018.7.8日更新 文章Demo","categories":[],"tags":[]},{"title":"我的第一篇博客","slug":"第一篇博客","date":"2018-08-25T16:28:22.314Z","updated":"2018-08-25T16:55:41.870Z","comments":true,"path":"2018/08/26/第一篇博客/","link":"","permalink":"https://github.com/sunsx9316/2018/08/26/第一篇博客/","excerpt":"","text":"\b最近决定要开始写博客了，打算先把简书的搬过来。这一年接触了很多东西，觉得需要记录下来，自己搭博客还蛮有意思的:)","categories":[],"tags":[]}]}