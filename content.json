{"meta":{"title":"Jim Huang的博客","subtitle":null,"description":null,"author":"Jim Huang","url":"https://github.com/sunsx9316"},"pages":[],"posts":[{"title":"UITableView+FDTemplateLayoutCell计算行高一些缺陷的解决方法","slug":"UITableView+FDTemplateLayoutCell计算行高一些缺陷的解决方法","date":"2018-08-25T16:58:20.706Z","updated":"2018-08-25T17:59:32.471Z","comments":true,"path":"2018/08/26/UITableView+FDTemplateLayoutCell计算行高一些缺陷的解决方法/","link":"","permalink":"https://github.com/sunsx9316/2018/08/26/UITableView+FDTemplateLayoutCell计算行高一些缺陷的解决方法/","excerpt":"","text":"#前言UITableView动态行高一直是iOS的一个经典问题，在没有AutoLayout的时代，只能自己计算frame，然后返回给代理，非常痛苦。到了AutoLayout的时代，布局就变得简单多了，甚至于通过系统提供的API都能自动计算出行高。 UITableView+FDTemplateLayoutCell就是sunnyxx大大的一个自动计算行高的框架。只要布局正确，通过它可以自动计算并缓存行高，非常方便。不过在使用上发现一些问题，也尝试去解决了。 #过程需求是这样的，一个类似微博的页面，像这样： 这应该是比较经典的布局，内容和图片都是不确定的，行高要根据实际数据计算。九宫格实现方式有很多，我这里是通过UICollectionView去实现的。这样的一个好处就是UICollectionView的高度可以通过它的collectionViewLayout对象获取，啥都不用算。不过会有一个问题，UICollectionView继承自UIScrollView，它的高度没法按照内容来全显示。所以即使布局正确，通过AutoLayout来计算行高也是不包括UICollectionView的，这个问题同样反映在一些UIView控件上。 这就十分蛋疼了，难道还要回到手算frame的时代？当然不是，是我还写啥博客。 我说下解决的几个方法。 方法一（不推荐）：手动设置collectionView的高度，可以通过代码或者xib来设置，我这里是xib。 像这样手动指定collectionView的高度，然后赋值数据源的时候更新collectionView高度约束就可以了，让它的高度等于它的contentSize.height，这样就能全部显示了，其它UIView控件也能这么解决。但是这样在计算行高的时候会抛出非常多异常，都是约束的问题。我不是很清楚这是什么原因，按理说计算再后，赋值在前，应该不会这样。而且显示会出一些问题，计算的行高会不正确，有些许误差。 方法二（推荐）：既然不能通过这种方式，那就绕个弯吧。去掉高度约束，计算出来的高就不包含collectionView的高。然后再手动加上collectionView的高返回给代理不就行了。不过看下UITableView+FDTemplateLayoutCell的拓展方法：12- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier configuration:(void (^)(id cell))configuration; 只有一个设置cell数据源的block，正常情况下我们只需要把cell换成我们自己的类，然后赋值模型就行，缓存之类的框架会自动处理好。虽然我们可以获取到缓存高度之后再加上collectionView的高，但是这样还叫啥缓存，缓存就是不需要计算，直接取到就能用，那怎么办呢？虽然可以通过Method Swizzling黑魔法交换方法实现，但是这并不是最优方法，往往是一些莫名其妙的bug的源泉，作为开发者应该尽量避免这种方式。所以最后我选择了通过分类的方式。思路是在框架计算完高度之后通过block返回，我们自行处理行高，加加减减，然后返回高度让框架缓存。具体代码：我们参考下框架这个方法的实现1234567891011121314151617181920- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier cacheByIndexPath:(NSIndexPath *)indexPath configuration:(void (^)(id cell))configuration &#123; if (!identifier || !indexPath) &#123; return 0; &#125; //命中缓存 if ([self.fd_indexPathHeightCache existsHeightAtIndexPath:indexPath]) &#123; [self fd_debugLog:[NSString stringWithFormat:@&quot;hit cache by index path[%@:%@] - %@&quot;, @(indexPath.section), @(indexPath.row), @([self.fd_indexPathHeightCache heightForIndexPath:indexPath])]]; return [self.fd_indexPathHeightCache heightForIndexPath:indexPath]; &#125; //计算行高 CGFloat height = [self fd_heightForCellWithIdentifier:identifier configuration:configuration]; [self.fd_indexPathHeightCache cacheHeight:height byIndexPath:indexPath]; [self fd_debugLog:[NSString stringWithFormat: @&quot;cached by index path[%@:%@] - %@&quot;, @(indexPath.section), @(indexPath.row), @(height)]]; return height;&#125; 它先从缓存中寻找行高，命中之后直接返回。否则计算行高，存入缓存，然后返回。所以很简单，我们可以直接复制它的代码。写一个带编辑行高功能的方法：12345678910111213141516171819202122232425262728293031typedef CGFloat(^editCellHeightAction)(id cell, CGFloat cellHeight);- (CGFloat)jh_heightForCellWithIdentifier:(NSString *)identifier cacheByIndexPath:(NSIndexPath *)indexPath configuration:(void (^)(id cell))configuration editAction:(editCellHeightAction)editAction &#123; if (!identifier || !indexPath) &#123; return 0; &#125; // Hit cache if ([self.fd_indexPathHeightCache existsHeightAtIndexPath:indexPath]) &#123; [self fd_debugLog:[NSString stringWithFormat:@&quot;hit cache by index path[%@:%@] - %@&quot;, @(indexPath.section), @(indexPath.row), @([self.fd_indexPathHeightCache heightForIndexPath:indexPath])]]; return [self.fd_indexPathHeightCache heightForIndexPath:indexPath]; &#125; CGFloat height = 0; //获取缓存中的cell UITableViewCell *templateLayoutCell = [self fd_templateCellForReuseIdentifier:identifier]; //这里插入编辑行高的代码 if (editAction) &#123; height = editAction(templateLayoutCell, [self fd_heightForCellWithIdentifier:identifier configuration:configuration]); &#125; else &#123; height = [self fd_heightForCellWithIdentifier:identifier configuration:configuration]; &#125; [self.fd_indexPathHeightCache cacheHeight:height byIndexPath:indexPath]; [self fd_debugLog:[NSString stringWithFormat: @&quot;cached by index path[%@:%@] - %@&quot;, @(indexPath.section), @(indexPath.row), @(height)]]; return height;&#125;&#125; 使用起来像这样：1234567891011- (CGFloat)tableView:(UITableView *)tableViewheightForRowAtIndexPath:(NSIndexPath *)indexPath &#123; return [tableView jh_heightForCellWithIdentifier:@&quot;MineCell&quot; cacheByIndexPath:indexPath configuration:^(HeSquareCell *cell) &#123; //正常赋值数据源 cell.model = self.model; &#125; editAction:^CGFloat(MineCell *cell, CGFloat cellHeight) &#123; //cellHeight是上面的block计算后回调过来的 所以直接加上额外的高度即可 //因为缓存的关系这里只会走一次 所以可以放心写 return cellHeight + [cell collectionViewHeightWithModel:self.model]; &#125;];&#125; 这样高度就能正常显示了，而且也不会抛异常，还能享受框架带来的便利。UITableView+FDTemplateLayoutCell的接口设计很易于拓展，所以写起来很简单。还有个问题，我发现在使用这个框架的时候，如果_tableView.tableFooterView = [[UIView alloc] init];这句话写在注册cell之前，程序会crash，不造为啥。如果各位有更好的解决思路或者文中有错误的地方欢迎给我留言。","categories":[],"tags":[]},{"title":"iOS的MobileVLCKit框架播放SMB协议视频的问题","slug":"iOS的MobileVLCKit框架播放SMB协议视频的问题","date":"2018-08-25T16:57:02.854Z","updated":"2018-08-25T16:57:03.313Z","comments":true,"path":"2018/08/26/iOS的MobileVLCKit框架播放SMB协议视频的问题/","link":"","permalink":"https://github.com/sunsx9316/2018/08/26/iOS的MobileVLCKit框架播放SMB协议视频的问题/","excerpt":"","text":"MobileVLCKit是开源播放器VLC的iOS平台框架，在Mac OS上也有对应的VLCKit，搞直播的同学应该不陌生，不过它其实还是一款强大的本地播放器，支持几乎所有的主流媒体格式。最近在研究app如何浏览电脑上文件，然后直接做到播放视频的功能。用过iOS上的VLC播放器的童鞋应该知道，他能做到扫描本地端口，然后通过输入用户名和密码浏览电脑的文件，点击视频和音频还能直接播放。通过Google知道这里用到一个叫SMB的协议，不光是Mac OS上，Windows和Linux都支持这种协议。只要本地开启SMB的文件共享服务，同一个局域网内的设备就能通过它访问电脑上的文件了。上上gayhub发现了一个SMB的iOS框架，叫TOSMBClient，它将一个C语言的框架封装成了OC的框架。还支持CocoaPods，使用起来非常方便。而MobileVLCKit原生就支持SMB协议的在线播放。所以解决方案是通过TOSMBClient获取文件列表，VLC播放，想法很美好，但是实际实现还是踩了不少坑。 先说说SMB的格式，长这样：smb://{hostname}:{password}@{ip}/path 比如桌面上的一个mp4文件就应该长这样：smb://xiaoming:123456@192.168.1.100/xiaoming/Desktop/233.mp4hostname是域名，一般创建SMB共享协议的时候，就需要指定。password是密码，ip是服务器的ip。TOSMBClient提供了一个登录的类叫TOSMBSession，常用属性是这几个12345678//服务器域名@property (nonatomic, copy) NSString *hostName;//服务器ip@property (nonatomic, copy) NSString *ipAddress;//登录的用户名@property (nonatomic, copy) NSString *userName;//登录密码@property (nonatomic, copy) NSString *password; 其中域名和ip可以都设置，也可以只设置其中一个，框架会自动查找。然后通过TOSMBSession提供的方法123- (void)requestContentsOfDirectoryAtFilePath:(NSString *)path success:(void (^)(NSArray *files))successHandler error:(void (^)(NSError *))errorHandler; 获取文件列表，很简单。返回的files是TOSMBSessionFile类型。它包含基本的文件信息，比如路径，名称，大小。想法挺美好，有URL，直接给VLC播放不就行了，然后就碰到了第一个坑。TOSMBSessionFile提供的路径只是smb格式的一部分，也就只有path部分，所以需要播放还得自己拼接成完整路径。 拼接好了之后尝试下播放个文件，没带中文的，成功了，高兴之余本着严谨的态度试了下中文路径，结果失败了。NSURL初始化如果包含标准ASCALL以外的字符，会返回nil，这是第二个坑。 作为程序员，很自然会想到，URL如果带中文，浏览器会自动做URL转码。\b所以尝试下转码，发现还是播放失败。这就让我怀疑人生了，怎么肥事？而且连iOS上的VLC的app都有这个问题，这是第三个坑。 通过查找API我发现播放器除了通过NSURL初始化，还可以通过NSString初始化，我想，NSURL不让包含中文，NSString总可以吧。结果还是播放失败，神奇的是即使不包含中文，通过NSString初始化还是失败，但是NSURL就可以，这是第四个坑。 既然一定要实现功能，那就得搞明白为什么，这时候开源的好处就体现出来了，我看了下MobileVLCKit的源码，它的媒体类VLCMedia是这么写的：123456789101112131415161718192021222324252627- (instancetype)initWithPath:(NSString *)aPath&#123; return [self initWithURL:[NSURL fileURLWithPath:aPath isDirectory:NO]];&#125;- (instancetype)initWithURL:(NSURL *)anURL&#123; if (self = [super init]) &#123; const char *url; VLCLibrary *library = [VLCLibrary sharedLibrary]; NSAssert(library.instance, @&quot;no library instance when creating media&quot;); if (([[anURL absoluteString] hasPrefix:@&quot;sftp://&quot;]) || ([[anURL absoluteString] hasPrefix:@&quot;smb://&quot;])) &#123; url = [[[anURL absoluteString] stringByRemovingPercentEncoding] UTF8String]; &#125; else &#123; url = [[anURL absoluteString] UTF8String]; &#125; p_md = libvlc_media_new_location(library.instance, url); _metaDictionary = [[NSMutableDictionary alloc] initWithCapacity:3]; [self initInternalMediaDescriptor]; &#125; return self;&#125; 可以看到，initWithPath:方法把字符串通过fileURLWithPath:isDirectory:方法初始化成URL了，所以smb格式的字符串路径通过这个方法初始化得到的路径肯定是错的，因为它不是标准的本地路径，自然会出现上面神奇的情况。然后看下initWithURL:方法，if语句判断如果包含smb前缀，则做URL解码操作。说明我们的想法是正确的，确实应该对URL进行编码。但是，经过测试编码还是不行，这种情况就很费解了。到现在我还不知道什么原因，因为它自己的APP都有这个问题。不过之后偶然发现了解决方法，很简单把URL编码两次即可！！把URL编码两次即可！！把URL编码两次即可！！ 重要的事情说三遍，编码两次之后框架会对URL解码一次，所以得到的URL实际是编码了一次的内容，这样就能播放了，非常神奇，这是第五个坑。在这里分享一下给需要的童鞋。 ###注意事项应该只对path、hostname、password部分做URL两次编码，smb://前缀不需要，否则播放器会无法识别。 2017.10.16日更新 如果发现拼接之后还是没法播放，大部分去因为VLC的版本比较旧的关系，cocoapods里有最新的unstable版本，用这个，不过这个版本也是最不稳定的。2018.7.8日更新 文章Demo","categories":[],"tags":[]},{"title":"我的第一篇博客","slug":"第一篇博客","date":"2018-08-25T16:28:22.314Z","updated":"2018-08-25T16:55:41.870Z","comments":true,"path":"2018/08/26/第一篇博客/","link":"","permalink":"https://github.com/sunsx9316/2018/08/26/第一篇博客/","excerpt":"","text":"\b最近决定要开始写博客了，打算先把简书的搬过来。这一年接触了很多东西，觉得需要记录下来，自己搭博客还蛮有意思的:)","categories":[],"tags":[]}]}