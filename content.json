{"meta":{"title":"Jim Huang的博客","subtitle":null,"description":"iOS App 移动开发 博客","author":"Jim Huang","url":"https://sunsx9316.github.io"},"pages":[],"posts":[{"title":"用更优雅的方式使用KVO","slug":"用更优雅的方式使用KVO","date":"2019-08-17T02:55:37.000Z","updated":"2019-08-17T03:06:31.955Z","comments":true,"path":"2019/08/17/用更优雅的方式使用KVO/","link":"","permalink":"https://sunsx9316.github.io/2019/08/17/用更优雅的方式使用KVO/","excerpt":"","text":"背景最近在做项目的改造工作，发现了项目中用到了不少KVO，而且是通过字符串硬编码的方式书写，正所谓复制一时爽，重构火葬场，底层重构属性的时候这种字符串是不会给错误或者警告提示的，造成了排查的困难。以前个人使用过一个叫libextobjc的拓展库，里面有一些对keypath的封装，可以在编译期生成并且检查keypath，非常方便。 用法这部分KVO的拓展叫EXTKeyPathCoding，官方注释说支持两种写法。 NSString *UTF8StringPath = @keypath(str.lowercaseString.UTF8String); // =&gt; @&quot;lowercaseString.UTF8String&quot; NSString *lowercaseStringPath = @keypath(NSString.new, lowercaseString); // =&gt; @&quot;lowercaseString&quot; 非常简洁明了，第一种比较直观，连续的点语法会截掉第一个&quot;.&quot;之前，保留之后的字符串。第二种只保留&quot;,&quot;后的字符串。值得一提的是对于类属性，也支持这种语法。比如这样：NSString *versionPath = @keypath(NSObject, version);// =&gt; @&quot;version&quot; 对于只是想了解用法的同学，下面的原理可以直接跳过，看最后的注意事项即可。 原理近来有同事问起原理，于是深入研究了下，感叹作者对宏定义用法的炉火纯青，现在把过程分享出来。 先看源码，对于@keypath，主要的宏定义是这样写的： 123456789101112131415#define keypath(...) \\ _Pragma(&quot;clang diagnostic push&quot;) \\ _Pragma(&quot;clang diagnostic ignored \\&quot;-Warc-repeated-use-of-weak\\&quot;&quot;) \\ (NO).boolValue ? ((NSString * _Nonnull)nil) : ((NSString * _Nonnull)@(cStringKeypath(__VA_ARGS__))) \\ _Pragma(&quot;clang diagnostic pop&quot;) \\#define cStringKeypath(...) \\ metamacro_if_eq(1, metamacro_argcount(__VA_ARGS__))(keypath1(__VA_ARGS__))(keypath2(__VA_ARGS__))#define keypath1(PATH) \\ (((void)(NO &amp;&amp; ((void)PATH, NO)), \\ (&#123; char *__extobjckeypath__ = strchr(# PATH, &apos;.&apos;); NSCAssert(__extobjckeypath__, @&quot;Provided key path is invalid.&quot;); __extobjckeypath__ + 1; &#125;)))#define keypath2(OBJ, PATH) \\ (((void)(NO &amp;&amp; ((void)OBJ.PATH, NO)), # PATH)) 看到的时候我的表情是黑人问号，幸好xcode有牛x闪闪的预处理功能，点击这里能看到： 对于@keypath(self.view)展开后去掉断言等无关代码，核心代码变成了这样： 12345@(__objc_no).boolValue ? ((NSString * _Nonnull)((void *)0)) : ((NSString * _Nonnull)@((((void)(__objc_no &amp;&amp; ((void)self.view, __objc_no)), (&#123; char *__extobjckeypath__ = strchr(&quot;self.view&quot;, &apos;.&apos;); __extobjckeypath__ + 1; &#125;))) )); 我们看到，这个宏定义就是一个三目运算符，接下来我们一步一步分析做了什么。 看第一行@(__objc_no).boolValue ? ((NSString * _Nonnull)((void *)0))，__objc_no就是NO，这里通过@(NO)将基本类型NO封装成了NSNumber。 而((NSString * _Nonnull)((void *)0))其实就是((NSString * _Nonnull)nil)。 所以这表达式简单写就是 @(NO).boolValue ? nil : 巴拉巴拉。或许你会疑惑这个三木运算符的意义何在，经过测试，移除掉没啥影响，我猜就是为了前面可以加一个酷炫的@符号吧。RAC里有@weakify这种写法也是要加@，其实也没什么用，就是为了酷炫，哈哈哈。 接下来我们看看第二行((NSString * _Nonnull)@((((void)(__objc_no &amp;&amp; ((void)self.view, __objc_no))，这句最大的意义其实就是提供了self.view让编译器能检查拼写。其实这里就是上面的#define keypath1 (void)(NO &amp;&amp; ((void)PATH, NO))展开的内容。这里用到了C语言里一些不太常用的写法。 1int c = (a, b) c最后的取值会是b。但是这样写编译器会报警告，简单的做法就是改成这样： 1int c = ((void)a, b) 所以这里写void的原因你也理解了吧。 然后看最后一句：({ char *__extobjckeypath__ = strchr(&quot;self.view&quot;, &#39;.&#39;); __extobjckeypath__ + 1; })。 这一句是由keypath1的后半部分展开而来。 strchr是c语言中寻找一个字符在另一个字符串中第一次出现的位置的函数，找到会返回位置的指针，没找到返回NULL。具体到这里，就是找到&#39;.&#39;在&quot;self.view&quot;中第一次出现的位置。这里+1相当于截断了&#39;.&#39;之前包括&#39;.&#39;的内容，所以能理解为什么它能找到对应的keypath了吧。{()}也是一个语法糖，会把最后一行做为表达式的返回值。好处就是在大括号中有自己的局部变量作用域，在临时变量很多，难以管理的时候这种写法可以比较优雅的解决问题。常见的写法像这样： 12345NSArray *arr = (&#123; NSMutableArray *mArr = [NSMutableArray array]; [mArr addObject:@(123)]; mArr; &#125;); 最后arr的取值会是mArr，不需要写return。 最后我们看到，返回值被@()包住，这是什么语法？我们知道@(123)这个语法糖会生成NSNumber，而比较少见的@(&quot;123&quot;)则会生成NSString。这里的char *__extobjckeypath__就是一个c的字符串，所以你理解为什么最后能生成了一个NSString了吧。 讲到这里我们梳理完了第一种keypath的写法，第二种写法原理大致相同，在宏定义中 # 变量名的写法会直接转换成c字符串，这就是第二种写法会把,之后的内容转换成字符串的基础。 总结我们可以看到作者对宏定义的运用到了非常高的水平，如果感兴趣，还可以阅读开源库里其它模块的代码，很值得研究。 说一下注意点，有同事在写keypath的时候写过类似这样的代码： @keypath(XXManager.shareManager.abc)，编译没有任何问题，跑起来却crash了，报错是xxx was sent to an object that is not KVC-compliant for the &quot;shareManager&quot; property.为什么？ 其实不是这个库的锅，因为shareManager是个类属性，它的get方法本质其实是个类方法，而只有实例属性才支持KVO，所以一定要小心。改法也很简单，使用第二种写法就行@keypath(FTManager.shareManager, abc) 参考Reactive Cocoa Tutorial [1] = 神奇的Macros","categories":[],"tags":[]},{"title":"Flutter学习笔记(一)","slug":"Flutter学习笔记(一)","date":"2019-03-31T13:27:53.000Z","updated":"2019-03-31T15:42:01.897Z","comments":true,"path":"2019/03/31/Flutter学习笔记(一)/","link":"","permalink":"https://sunsx9316.github.io/2019/03/31/Flutter学习笔记(一)/","excerpt":"","text":"前言\b近来大前端时代成为了一个很火热的词，各种跨平台的前端框架也不断涌现。不过我个人其实并不太看好这种框架，个人感觉一套代码全平台通用的想法是很好，但是平台是存在差异性的，特别是每个平台还有很多特有的属性，所以要做好终归只能原生。不过作为程序员，学习和了解新技术总没什么错，特别是要清楚本质，所以这里记录下自己学习flutter的过程。 Flutter是啥flutter是Google开发，用于跨平台开发(目前支持Android和iOS)的一个框架。相比于H5+原生混合开发、React Native或Weex，flutter诞生的比较晚，从第一个beta版本到现在也不过一年。但是可以看到在Google强大的号召力下，开源社区非常火热。\b\bflutter和React Native、Weex这些框架最大的区别，应该在于flutter采用自绘引擎，既不使用原生控件，也不使用webView。这样的好处是能做到多端UI表现的一致，\b也就是真正意义的跨平台了。不过UI其实只是一部分，将来希望能做到更多API的统一。 安装万丈高楼平地起，这一章主要说安装。 flutter的社区很火热，在国内有专门的中文网，仔细阅读就能解决国内开发基本都会碰到的问题。所以上面写了的我就简单略过，只讲自己碰到的坑。 因为安卓是亲儿子，flutter对于Android的支持完善的多，而苦逼的iOS搭建完整的开发环境还是相对麻烦。本人使用VSCode+插件的方式开发，\b\b前面的配置环境变量，安装插件什么的一切顺利，主要问题出现在了安装iOS设备工具这里。 本人使用的是稳定版本，目前是v1.2.1。官方的说明很简单，通过Homebrew一键安装：1234brew updatebrew install --HEAD libimobiledevicebrew install ideviceinstaller ios-deploy cocoapodspod setup 问题出在了brew install --HEAD libimobiledevice这个东西上。因为Homebrew会自动检测包依赖，然后他帮我装了python，这就是噩梦的开始。 默认Homebrew安装的是python3，而Mac OS自带的是python2。所以就会出现两个版本。不过不用担心Homebrew会帮你处理好。由于本人python只是略懂皮毛，所以以下的处理方式可能在专业人士看来比较不妥，有更好的方式欢迎给我提issue。 安装出现了这个错误： 1234567891011checking consistency of all components of python development environment... noconfigure: error: Could not link test program to Python. Maybe the main Python library has been installed in some non-standard library path. If so, pass it to configure, via the LDFLAGS environment variable. Example: ./configure LDFLAGS=&quot;-L/usr/non-standard-path/python/lib&quot; ============================================================================ ERROR! You probably have to install the development version of the Python package for your distribution. The exact name of this package varies among them. ============================================================================ emmm …… 我当时就是这个表情 查了下发现libimobiledevice这是一个用来和iPhone通信的库，如果不管其实也可以，但是就没法体验flutter的热重载了。所以我们还是得上。错误大致上是说不能链接到python。于是看了看flutter在github上的issue，发现还真有人碰到。大致说这是Homebrew的问题，但是解决方法没说明白。再google，有一些和flutter无关的搜索结果，给出的解决方案大多是安装python-dev，这玩意是Linux上的，mac没有，那就只能自己琢磨了。 一开始猜测可能是多版本python的问题，导致脚本找不到python真正的目录，google之后发现可以通过配置$PATH的方式将python路径加入到环境变量中。命令如下：1export PATH=$&#123;PATH&#125;:/Library/Frameworks/Python.framework/Versions/3.6/bin 满怀希望的再装一次，发现还是报这个错。于是看看他的log，有这么一段话： 12via the LDFLAGS environment variable. Example: ./configure LDFLAGS=&quot;-L/usr/non-standard-path/python/lib&quot; 大概是让我执行./configure这个文件的时候指定LDFLAGS这个环境变量为外部的python路径。log里有报错的脚本路径，我的在这里： 1~/Library/Caches/Homebrew/libimobiledevice: cd到这个目录，发现是Homebrew缓存libimobiledevice安装脚本的目录。里面有Log提到的configure文件。熟悉Linux的同学应该知道这玩意，这个是手动编译一些库的时候常见的配置脚本。其实这里就是要我们自己手动安装了。好，那我们自己手动加上Python的外部路径，Homebrew的python安装在这里:1/usr/local/Cellar/python/3.7.3/Frameworks/Python.framework/Versions/3.7/lib 在当前目录执行1./configure LDFLAGS=&quot;-L/usr/local/Cellar/python/3.7.3/Frameworks/Python.framework/Versions/3.7/lib&quot; 满心欢喜，发现并没有什么卵用。以为是书写方式或者路径不对，做了很多尝试，依然无果。 只能看看脚本写的是啥了。 编辑器打开./configure，发现是个shell脚本。搜了下报错信息，发现了这么些代码：12345678910if ac_fn_c_try_link &quot;$LINENO&quot;; then : pythonexists=yeselse pythonexists=nofirm -f core conftest.err conftest.$ac_objext \\ conftest$ac_exeext conftest.$ac_ext &#123; $as_echo &quot;$as_me:$&#123;as_lineno-$LINENO&#125;: result: $pythonexists&quot; &gt;&amp;5$as_echo &quot;$pythonexists&quot; &gt;&amp;6; &#125; 以我半桶水的shell基础大致就是尝试链接python，底下的代码会通过pythonexists这个标识判断是否链接成功。我们的python其实是能找到的，但是上面的代码不知道为啥报错了，于是我试着在rm -f core conftest.err conftest.$ac_objext的上一行直接粗暴的把pythonexists改为yes。像这样： 1234567if ac_fn_c_try_link &quot;$LINENO&quot;; then : pythonexists=yeselse pythonexists=nofipythonexists=yes # 加入这行rm -f core conftest.err conftest.$ac_objext \\ 保存运行，发现真的没报这个错了。但是又迎来了另一个错误： 12checking for openssl &gt;= 0.9.8... noconfigure: error: OpenSSL support explicitly requested but OpenSSL could not be found WTF？OpenSSL我明明装了，这又搞毛线。google一下发现是mac自带的版本比较旧，最简单的方法是这样：1./autogen.sh --disable-openssl 然后居然没报错，Every Thing is OK. 接下来 make install就好了。 然后没有两秒又报错了？？？ 好吧，看看报错。12/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.14.sdk/usr/include/inttypes.h:250:8: error: unknown type name &apos;intmax_t&apos; 说的是系统的SDK里没有定义intmax_t这东西，猜测是编译版本的问题。goolge发现人家直接简单粗暴给你加上定义。我们打开Xcode看下intmax_t的定义。 长这样的 123456789101112#ifndef _INTMAX_T#define _INTMAX_T#ifdef __INTMAX_TYPE__typedef __INTMAX_TYPE__ intmax_t;#else#ifdef __LP64__typedef long int intmax_t;#elsetypedef long long int intmax_t;#endif /* __LP64__ */#endif /* __INTMAX_TYPE__ */#endif /* _INTMAX_T */ 其实就是个INTMAX的别名。然后我们把他粘贴到上面报错的头文件中。(uintmax_t也是一样) 之后出现的错误都类似处理，补全定义。 然后，编译通过了~ 当然，随便改系统定义的头文件不知道会有什么后果，所以在安装完成之后我就把他复原了。接下来试试flutter的热重载，正常，安装到此结束。 后记其实还尝试过Android Studio，结果新建flutter工程直接卡死，心累不想找解决方案了，以后flutter能省点心就好了。","categories":[],"tags":[]},{"title":"对于订阅和反订阅的一些思考","slug":"对于订阅和反订阅的一些思考","date":"2018-12-15T07:50:44.000Z","updated":"2019-08-07T14:41:56.657Z","comments":true,"path":"2018/12/15/对于订阅和反订阅的一些思考/","link":"","permalink":"https://sunsx9316.github.io/2018/12/15/对于订阅和反订阅的一些思考/","excerpt":"","text":"前言因为项目的一些历史原因，最近在进行重构，碰到了一些比较核心的订阅部分，写出来记录一下。 订阅这个概念我是首先在RAC里见到。在响应式编程里一切都是数据流，RAC在实现上创建了信号和订阅的概念，你可以监听信号的变化，iOS底层是通过KVO和运行时实现的。KVO大家应该比较熟悉，网上说它原理的文章太多了，大致就是通过运行时动态创建子类，hook属性的set方法，在值改变的时候回调，不过我们需要自己手动移除监听，否则会存在内存问题，这个设计饱受诟病。从Swift 4.0开始，KVO有了一种新的写法。API是这样的：123func observe&lt;Value&gt;(_ keyPath: KeyPath&lt;Observer, Value&gt;, options: NSKeyValueObservingOptions = default, changeHandler: @escaping (Observer, NSKeyValueObservedChange&lt;Value&gt;) -&gt; Void) -&gt; NSKeyValueObservation 然后我们就可以这样写：1234567891011class TestObj: NSObject &#123; @objc dynamic var str = &quot;&quot; var observer: NSKeyValueObservation? func testKVO() &#123; self.observer = self.observe(\\.str, options: .new) &#123; (obj, values) in print(values) &#125; &#125;&#125; 这里需要注意的是必须创建一个强引用持有返回的对象，否则监听事件就无效了。这个对象的类型是NSKeyValueObservation，结构很简单，定义是这样的。 12345public class NSKeyValueObservation : NSObject &#123; ///invalidate() will be called automatically when an NSKeyValueObservation is deinited public func invalidate()&#125; 注释说这个对象在释放的时候会自动解除引用，也就是说不需要我们自己手动移除KVO监听了，监听事件和对象的生命周期绑定。RAC的里的RACKVOTrampoline就是这种实现的一个例子。 目的先说说业务场景。App在某些页面需要给服务器发送指令，请求返回相应的数据。项目里因为对数据实时性要求比较高，而且为了统一前端和移动端，使用了WebSocket协议。指令存在很多种类型，有针对单个Tab的，或者详情页中针对单个币种的，他们之间互不影响。但是和订阅一样，有订阅就有反订阅，所以在不需要的时候需要向服务器发送取消的指令。所以我希望这里的指令能像上面说的订阅模型一样，在对象销毁的时候自动发送取消指令。RAC有一套比较完整的订阅模式，但是依赖比较严重，项目中希望慢慢移除掉它，所以实现了一个更贴近业务轻量的框架。 实现其实指令大致就分为两类，一种是tab指令，一种是单个币种的指令。单就这两个就没什么好说的了，无非就是页面出现的时候创建指令对象，发指令给服务器，页面销毁也就发送取消的指令给服务器，中断数据传输。唯一一个复杂的点在单个币种指令的集合。因为有一种业务场景是这样的，本地允许用户添加自选，不上传服务器。那么服务器没办法知道用户的自选列表里有什么，传什么数据就需要App自己指定。当时为了赶需求，这种方式就直接使用了单个指令，有多少个自选币种，就创建多少个指令对象。虽然简单粗暴，但是在取消的时候就有一些麻烦了。后来重构，发现确实也只有这种方式可行，这和业务场景有关。比如我从本地自选A页面跳转到某个需要发送单个指令的页面B，这时候订阅对象应该是复用的，因为从B页面回到A的时候，单个指令也并不应该销毁，因为A页面依然持有它。当时为了这个问题头疼了很久，后来恍然大悟，这不就是和MRC原理差不多嘛。 明白了之后就很简单了。 首先在自选列表A页面需要发送指令的时候由一个全局的管理器创建一个指令对象给A页面持有，因为列表允许多个单指令集合，所以管理器需要把这些单个对象组合成一个集合C返回。 跳转到B页面时，同样需要通过管理器创建指令，管理器发现这个单指令存在，那么就不要创建了，返回它的引用，这时候集合C的引用计数就是2。 B页面在销毁的时候引用计数-1，但是因为A页面的持有，集合C实际上引用计数还是1，不会释放，也就不会发送取消指令。 看似可行的方案，实践中碰上了一些问题。按照MRC的规则，谁创建，谁释放，那么A页面在销毁的时候按理说集合C也要销毁，但是管理器也需要持有集合C，这样其它页面来请求指令的时候才能知道应该创建新的指令对象还是应该返回引用。但是管理器不应该强持有集合C，不然集合C就永远无法释放了。所以管理器在持有集合C的时候需要弱引用。这里用到了NSHashTable，它的用法和NSArray很相似，但是NSHashTable可以持有弱引用的对象。 所以博客到这里就写完了吗？当然没有。还有一个最大的发送取消集合C的指令的问题。服务器提供了一个批量取消单指令的指令，很适合集合C的场景。想法很简单，在集合C销毁的时候把它持有的单指令批量取消，就不需要一个个的去发送取消的指令了。那么问题来了，集合C怎么知道哪些单个指令需要取消，哪些不需要呢。而且集合C必须强持有它的单个指令，按照释放顺序，在集合C走到deinit方法的时候，它的属性是还能访问的。所以我们需要让集合C的单指令提前释放，并且还需要知道哪些单个指令需要发送取消指令，哪些不需要。核心代码如下： 123456789101112131415161718192021222324252627282930313233343536373839class ListSubscribeObservation &#123; //单订阅的数组 var children: [SingleSubscribeObservation]? deinit() &#123; //持有一份单指令的弱引用 然后让单指令集合提前释放 //如果弱引用还存在 那么说明还有地方在强应用这个单指令 那么不应该把它取消 let obsTable = NSHashTable&lt;SingleSubscribeObservation&gt;(options: [.weakMemory, .objectPointerPersonality], capacity: 0) //要发送给服务器的指令集 var subKeys = [String]() autoreleasepool &#123; while let obj = self.children?.popLast() &#123; obsTable.add(obj) //这个标记用于表示是否应该发送取消指令 item.autoUnsub = false subKeys.append(obj.value) &#125; &#125; //走到这里单指令集合应该已经被提前释放了 剩下的则不应该发送指令 将它移除出数组 for item in obsTable.objectEnumerator() &#123; if let item = item as? SingleSubscribeObservation &#123; //从批量释放中移除 if subKeys.contains(item.value) &#123; //恢复单订阅自动释放 item.autoUnsub = true subKeys.remove(item.value) &#125; &#125; &#125; if subKeys.count &gt; 0 &#123; //发送订阅指令 let ws = WebSocket.shared ws.removeKeys(subKeys) &#125; &#125; &#125; 但是实际上在某些时候即使这样写，children仍然会在这个对象之后释放，所以最后的办法是在业务层加了延迟发送指令的代码。因为children最后一定会释放，它内部的单个指令也会快速释放，但是走的是单个释放的。所以做法是释放时通过定时器delay个0.1s，如果0.1s内再次走了这个方法，则把上一次的timer取消掉，否则执行批量释放，代码如下： 12345678910111213141516171819202122232425262728class WebSocket &#123;// 临时需要移除订阅的数组private var tempRemoveKeys = Set&lt;String&gt;()func removeKeys(_ keys: [String]) &#123; if keys.count == 0 &#123; return &#125; //使用临时集合保存释放的key self.tempRemoveKeys.formUnion(keys) //短时间的批量释放合并到一起处理 self.removeDelayTimer?.invalidate() self.removeDelayTimer = Timer.scheduledTimer(withTimeInterval: 0.2, block: &#123; [weak self] (_) in guard let self = self else &#123; return &#125; let tempKeys = Array(self.tempRemoveKeys) //发送取消指令 self.unsubKeys(tempKeys) //移除临时集合 self.tempRemoveMarkets.removeAll() &#125;, repeats: false) &#125;&#125; 总结其实这个解决方案并不算好，导致调用时机没有按照预期执行的原因有待研究，这里对思考过程做一个记录。","categories":[],"tags":[]},{"title":"iOS的MobileVLCKit框架播放SMB协议视频的问题","slug":"iOS的MobileVLCKit框架播放SMB协议视频的问题","date":"2018-08-26T10:46:38.209Z","updated":"2018-08-26T10:46:38.209Z","comments":true,"path":"2018/08/26/iOS的MobileVLCKit框架播放SMB协议视频的问题/","link":"","permalink":"https://sunsx9316.github.io/2018/08/26/iOS的MobileVLCKit框架播放SMB协议视频的问题/","excerpt":"","text":"MobileVLCKit是开源播放器VLC的iOS平台框架，在Mac OS上也有对应的VLCKit，搞直播的同学应该不陌生，不过它其实还是一款强大的本地播放器，支持几乎所有的主流媒体格式。最近在研究app如何浏览电脑上文件，然后直接做到播放视频的功能。用过iOS上的VLC播放器的童鞋应该知道，他能做到扫描本地端口，然后通过输入用户名和密码浏览电脑的文件，点击视频和音频还能直接播放。通过Google知道这里用到一个叫SMB的协议，不光是Mac OS上，Windows和Linux都支持这种协议。只要本地开启SMB的文件共享服务，同一个局域网内的设备就能通过它访问电脑上的文件了。上上gayhub发现了一个SMB的iOS框架，叫TOSMBClient，它将一个C语言的框架封装成了OC的框架。还支持CocoaPods，使用起来非常方便。而MobileVLCKit原生就支持SMB协议的在线播放。所以解决方案是通过TOSMBClient获取文件列表，VLC播放，想法很美好，但是实际实现还是踩了不少坑。 先说说SMB的格式，长这样：smb://{hostname}:{password}@{ip}/path 比如桌面上的一个mp4文件就应该长这样：smb://xiaoming:123456@192.168.1.100/xiaoming/Desktop/233.mp4hostname是域名，一般创建SMB共享协议的时候，就需要指定。password是密码，ip是服务器的ip。TOSMBClient提供了一个登录的类叫TOSMBSession，常用属性是这几个12345678//服务器域名@property (nonatomic, copy) NSString *hostName;//服务器ip@property (nonatomic, copy) NSString *ipAddress;//登录的用户名@property (nonatomic, copy) NSString *userName;//登录密码@property (nonatomic, copy) NSString *password; 其中域名和ip可以都设置，也可以只设置其中一个，框架会自动查找。然后通过TOSMBSession提供的方法123- (void)requestContentsOfDirectoryAtFilePath:(NSString *)pathsuccess:(void (^)(NSArray *files))successHandler error:(void (^)(NSError *))errorHandler; 获取文件列表，很简单。返回的files是TOSMBSessionFile类型。它包含基本的文件信息，比如路径，名称，大小。想法挺美好，有URL，直接给VLC播放不就行了，然后就碰到了第一个坑。TOSMBSessionFile提供的路径只是smb格式的一部分，也就只有path部分，所以需要播放还得自己拼接成完整路径。 拼接好了之后尝试下播放个文件，没带中文的，成功了，高兴之余本着严谨的态度试了下中文路径，结果失败了。NSURL初始化如果包含标准ASCALL以外的字符，会返回nil，这是第二个坑。 作为程序员，很自然会想到，URL如果带中文，浏览器会自动做URL转码。\b所以尝试下转码，发现还是播放失败。这就让我怀疑人生了，怎么肥事？而且连iOS上的VLC的app都有这个问题，这是第三个坑。 通过查找API我发现播放器除了通过NSURL初始化，还可以通过NSString初始化，我想，NSURL不让包含中文，NSString总可以吧。结果还是播放失败，神奇的是即使不包含中文，通过NSString初始化还是失败，但是NSURL就可以，这是第四个坑。 既然一定要实现功能，那就得搞明白为什么，这时候开源的好处就体现出来了，我看了下MobileVLCKit的源码，它的媒体类VLCMedia是这么写的：123456789101112131415161718192021222324252627- (instancetype)initWithPath:(NSString *)aPath&#123; return [self initWithURL:[NSURL fileURLWithPath:aPath isDirectory:NO]];&#125;- (instancetype)initWithURL:(NSURL *)anURL&#123; if (self = [super init]) &#123; const char *url; VLCLibrary *library = [VLCLibrary sharedLibrary]; NSAssert(library.instance, @&quot;no library instance when creating media&quot;); if (([[anURL absoluteString] hasPrefix:@&quot;sftp://&quot;]) || ([[anURL absoluteString] hasPrefix:@&quot;smb://&quot;])) &#123; url = [[[anURL absoluteString] stringByRemovingPercentEncoding] UTF8String]; &#125; else &#123; url = [[anURL absoluteString] UTF8String]; &#125; p_md = libvlc_media_new_location(library.instance, url); _metaDictionary = [[NSMutableDictionary alloc] initWithCapacity:3]; [self initInternalMediaDescriptor]; &#125; return self;&#125; 可以看到，initWithPath:方法把字符串通过fileURLWithPath:isDirectory:方法初始化成URL了，所以smb格式的字符串路径通过这个方法初始化得到的路径肯定是错的，因为它不是标准的本地路径，自然会出现上面神奇的情况。然后看下initWithURL:方法，if语句判断如果包含smb前缀，则做URL解码操作。说明我们的想法是正确的，确实应该对URL进行编码。但是，经过测试编码还是不行，这种情况就很费解了。到现在我还不知道什么原因，因为它自己的APP都有这个问题。不过之后偶然发现了解决方法，很简单把URL编码两次即可！！把URL编码两次即可！！把URL编码两次即可！！ 重要的事情说三遍，编码两次之后框架会对URL解码一次，所以得到的URL实际是编码了一次的内容，这样就能播放了，非常神奇，这是第五个坑。在这里分享一下给需要的童鞋。 注意事项应该只对path、hostname、password部分做URL两次编码，smb://前缀不需要，否则播放器会无法识别。 2017.10.16日更新 如果发现拼接之后还是没法播放，大部分是因为VLC的版本比较旧的关系，cocoapods里有最新的unstable版本，用这个，不过这个版本也是最不稳定的。 2018.7.8日更新 文章Demo","categories":[],"tags":[]},{"title":"APP切换主题的一些思考","slug":"APP切换主题的一些思考","date":"2018-08-26T07:14:17.000Z","updated":"2019-08-17T03:01:07.739Z","comments":true,"path":"2018/08/26/APP切换主题的一些思考/","link":"","permalink":"https://sunsx9316.github.io/2018/08/26/APP切换主题的一些思考/","excerpt":"","text":"前言APP内切换主题是比较常见的需要，蛮早就思考过这个问题。网上也有很多的解决方案，不过本质上其实都类似，无非是两种情况。 如果需要实现类似手Q那样动态更换主题，那么主题一定是个配置文件，能够从服务器下载。 如果只要求能更换成本地的几套主题，那只通过代码初始化，写死也是可以的。 说说两者的优缺点。 第一种比较灵活，但是引入的配置文件肯定要求格式的通用，毕竟不太可能要求服务端针对不同的设备提供不同的配置。那么很多人或许会选择JSON或者XML之类的格式。这样就会导致可读性不那么好，也不太直观，而且也没办法在编译期就做代码检查。 第二种对比第一种就更直观，没有什么能比 label.textColor = redColor 这样的代码更易读了吧。同时因为是原生开发，也可以在编译期就做到代码检查，缺点就是灵活性差了些。 所以要做的其实是选择适合自己的类型，还有如何能更简单的做到切换而已。这个轮子其实并不太适合项目，更多是作为思考。公司项目并不要求做到类似手Q那样动态切换主题，但是为了拓展性，我还是考虑通过配置文件去加载。 目的因为写主题配置是十分麻烦的事，我想要做到的效果是只写配置文件，代码里不需要写任何判断和设置的逻辑就能做到自动根据当前主题切换样式。所以要做的事分为以下几步： 书写配置 程序读取配置 代码根据当前主题自动设置样式 同时配置文件要求可读性良好，就算别人接手了这个模块也不需要熟悉特定的配置书写语法。 实现配置文件因为是本地使用，那么可以不考虑通用性，为了开发简单，我们使用Plist写配置。为了可读性良好，且尽量不增加学习成本，我想做到最好写在配置里的就是类似 label.textColor = redColor 这样的赋值语句。那能不能做到这一点呢，当然可以，我们可以借助OC的KVC。KVC本身也支持keyPath这样的赋值方式，&quot;label.textColor&quot; 这样的字符串在KVC中会被解析成查找 label 下的 textColor 属性。所以我们在 Plist \b里的 key就可以定义成 &quot;label.textColor&quot;，而 value就是颜色。 那么问题来了，Plist 只支持字符串、数字、日期、二进制流这几种有限的格式，那怎么让它支持颜色呢？很容易联想到颜色16进制的表示方式，比如白色使用16进制表示就是 #FFFFFF，所以直接使用字符串不就好了。但是问题没这么简单。 一种比较常见的需求是在不同的主题下需要显示不同图片 (比如我们就有白天和黑夜模式，黑夜模式的图片就要求暗一些。小声bb……)，颜色如果使用了 #FFFFFF 这样的方式设置，那么图片怎么办？图片可以根据图片名，但是程序需要知道这个字符串是什么才能把它转成对应的东西，所以就需要定一套简单的规则了。 字符串非常灵活，任意的组合可以得到完全不同的内容，所以对于这种情况，选择字符串类型是比较合适的。类似编译器，有一套自己的复杂的解析规则，会把字符串转换为语法树。我们不需要这么复杂，只是简单的格式就好，但是可以设计成拥有很强拓展性的模式。所以我们需要定义一些通用的接口，生成一些解析器，这会在第二步详细说明。 读取配置这一步比较重要的是接口的设计，关乎到使用的方便性和未来的拓展性。 我们接着说第一步末尾说到的解析器。为什么要定义解析器呢？首先每一个 Plist的对象，值传过来都是个字符串，我们要根据里面字符串的格式判断它是应该解析成颜色，或者图片又或者是其它。每种情况都不一样，所以拆分成独立的解析器会更好。不过他们都用一个共同点，遵守同一个协议。协议我们这样定义： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** 解析优先级 - JHThemeParserPriorityRequest: 最先解析 - JHThemeParserPriorityNormal: 普通 - JHThemeParserPriorityUnimportance: 最后解析 */typedef NS_ENUM(NSUInteger, JHThemeParserPriority) &#123; JHThemeParserPriorityUnimportance, JHThemeParserPriorityNormal, JHThemeParserPriorityRequest = 1000,&#125;;@class JHTheme;@protocol JHThemeParserProtocol &lt;NSObject&gt;/** 解析优先级 */@property (nonatomic, assign, readonly) JHThemeParserPriority priority;/** 唯一标识 */@property (nonatomic, copy, readonly) NSString *identify;/** 是否在解析之后直接返回 YES会将解析结果让之后的解析器继续解析 */@property (nonatomic, assign, readonly) BOOL continueParse;/** 是否能解析这个值 @param value 值 @return 是否能解析这个值 */- (BOOL)canParseValue:(id)value;/** 解析具体实现 @param value 值 @param currentTheme 当前主题 @return 解析结果 */- (id)converValue:(id)value currentTheme:(JHTheme *)currentTheme;@end 重要的是这两个方法：12- (BOOL)canParseValue:(id)value;- (id)converValue:(id)value currentTheme:(JHTheme *)currentTheme; 第一个方法判断这个解析器能否解析这个字符串。 如果返回 true ， 那么会接着调用converValue:(id)value currentTheme:(JHTheme *)currentTheme，让解析器自己内部进行解析。 如果返回 false，那么这个解析器就无法解析这个字符串，也不会有之后的调用了。 举个简单的例子，这是颜色解析器内部的实现：123456789101112131415161718192021222324252627282930@implementation JHThemeColorParser- (BOOL)canParseValue:(NSString *)value &#123; if ([value isKindOfClass:[NSString class]] &amp;&amp; ([value hasPrefix:@&quot;c(&quot;] || [value hasPrefix:@&quot;C(&quot;]) &amp;&amp; [value hasSuffix:@&quot;)&quot;]) &#123; return YES; &#125; return NO;&#125;- (id)converValue:(NSString *)value currentTheme:(JHTheme *)currentTheme &#123; //取出色值 value = [value substringWithRange:NSMakeRange(2, value.length - 3)]; NSArray &lt;NSString *&gt;*rgba = [value componentsSeparatedByString:@&quot;,&quot;]; //16进制 if (rgba.count == 1) &#123; return [UIColor colorWithHexString:value]; &#125; else if (rgba.count &gt;= 3) &#123; CGFloat r = 0,g = 0,b = 0,a = 1; r = rgba.firstObject.doubleValue / 255.0; g = rgba[1].doubleValue / 255.0; b = rgba[2].doubleValue / 255.0; if (rgba.count &gt;= 4) &#123; a = rgba[3].doubleValue; &#125; return [UIColor colorWithRed:r green:g blue:b alpha:a]; &#125; return value;&#125;@end 首先 - (BOOL)canParseValue:(id)value 这个方法的实现是判断值是否符合规则，这里我定义成符合 c(#FFFFF) 或者 c(255,255,255) 格式的字符串就可以解析。前者是颜色的16进制表示法，后者是通过指定RGB数字的颜色表示法。而下面只是对这个解析格式的实现而已。这样做的好处是如果想定义一套比较复杂的解析规则，只要实现协议，自己写解析逻辑就好了。比如除了颜色的，我还实现了一些类似宏的解析逻辑。像这样： 123456789101112131415161718192021222324- (BOOL)canParseValue:(NSString *)value &#123; if ([value isKindOfClass:[NSString class]] &amp;&amp; ([value hasPrefix:@&quot;d(&quot;] || [value hasPrefix:@&quot;D(&quot;]) &amp;&amp; [value hasSuffix:@&quot;)&quot;]) &#123; return YES; &#125; return NO;&#125;- (id)converValue:(NSString *)value currentTheme:(JHTheme *)currentTheme &#123; NSString *tempStr = [[value substringWithRange:NSMakeRange(2, value.length - 3)] stringByTrim]; NSDictionary *mapDic = currentTheme.defineMap; id map = mapDic[tempStr]; if (map) &#123; return map; &#125; return value;&#125;- (BOOL)continueParse &#123; return YES;&#125;- (JHThemeParserPriority)priority &#123; return JHThemeParserPriorityRequest;&#125; 场景是APP有一个主题色，如果按照上面只是通过指定颜色去写，那就会很麻烦，而且一旦主题色更换，也要全局修改。这个宏解析器就定义了一种字符串格式像这样 d(mainColor)。配置文件有一个独立的”宏字典”，解析器取出 mainColor 然后在”宏字典”里查找 mainColor对应的 value是什么，这个 value 我只要定义成c(#FFFFF) 或者其它解析器可以解析的格式，就可以做到类似宏定义的替换效果。需要注意的是 - (BOOL)continueParse 需要返回 YES，这样解析的结果才能返回给其它的解析器继续解析。 所以可以看到，这样是非常灵活的。 自动设置样式这一步其实相对来说比较容易了，但是也有不少值得说的地方。我这里定义了一个叫 themeManager 的主题管理类。接口这样设计： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** 自定义操作block @param aObj 更改的对象 @param key 键 @param value 值 @return 自定义更改的对象 */typedef id(^JHThemeCustomAction)(id aObj, NSString *key, id value);@class JHThemeManager;@protocol JHThemeManagerObserver&lt;NSObject&gt;@optional//主题改变回调- (void)themeManager:(JHThemeManager *)themeManager didChangeTheme:(JHTheme *)theme;@end@interface JHThemeManager : NSObject+ (instancetype)shareThemeManager;@property (nonatomic, strong, readonly) JHTheme *currentTheme;/** 注册自定义解析器 @param parserClass 解析器需要实现 JHThemeParserProtocol接口 */- (void)registerParser:(Class)parserClass;/** 添加单个主题 @param theme 主题对象 */- (void)addTheme:(JHTheme *)theme;/** 添加多个主题 @param themes 主题数组 */- (void)addThemes:(NSArray &lt;JHTheme *&gt;*)themes;/** 根据主题名称更改当前主题 @param themeName 主题名称 */- (void)updateThemeByName:(NSString *)themeName;/** 根据当前主题更新对象的样式 @param obj 对象 @param themeKey 主题下的Key 空则为obj的类名 @param block 自定义操作 */- (void)updateObjStyleWithCurrentTheme:(id)obj themeKey:(NSString *)themeKey block:(JHThemeCustomAction)block;/** 根据当前主题更新对象的样式 @param obj 对象 @param themeKey 主题下的Key 空则为obj的类名 @param themeName 主题名称 @param block 自定义操作 */- (void)updateObjStyleWithCurrentTheme:(id)obj themeKey:(NSString *)themeKey themeName:(NSString *)themeName block:(JHThemeCustomAction)block;- (void)addObserver:(id&lt;JHThemeManagerObserver&gt;)observer;- (void)removeObserver:(id&lt;JHThemeManagerObserver&gt;)observer;@end - (void)registerParser:(Class)parserClass 注册的是遵守了解析器协议的类，只有注册了才支持解析这种类型的字符串。内部实现是通过数组保存示例，解析的时候根据优先级循环调用已经注册的解析器进行解析。 然后重点是自动。因为我们的 key 是 keyPath的形式，所以直接通过KVC把解析结果赋值就行。 实现如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208- (void)updateObjStyleWithCurrentTheme:(id)toObj themeKey:(NSString *)themeKey themeName:(NSString *)themeName block:(JHThemeCustomAction)block &#123; if (toObj == nil) return; if (themeKey.length == 0) &#123; themeKey = NSStringFromClass([toObj class]); &#125; JHTheme *aTheme = nil; if (themeName.length == 0) &#123; aTheme = self.currentTheme; &#125; else &#123; aTheme = [self themeByName:themeName]; &#125; //获取当前主题所有存储的内容 NSDictionary *content = aTheme.content[themeKey]; if ([content isKindOfClass:[NSDictionary class]] == NO) return; [content enumerateKeysAndObjectsUsingBlock:^(NSString * _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123; //自定义修改 if (block) &#123; obj = block(toObj, key, [self converValueWithObj:obj]); if (obj == nil) return; &#125; NSString *cacheKey = [themeKey stringByAppendingFormat:@&quot;.%@&quot;, key]; NSNumber *cache = [self.keyPathCache objectForKey:cacheKey]; //没有缓存过 if (cache == nil) &#123; NSArray &lt;NSString *&gt;*keyPaths = [key componentsSeparatedByString:@&quot;.&quot;]; id lastObj = toObj; //单个key if (keyPaths.count == 1) &#123; //当前key不存在 BOOL exist = [lastObj respondsToSelector:NSSelectorFromString(keyPaths.firstObject)]; NSAssert(exist, @&quot;%@不存在 设置主题失败&quot;, key); if (exist == false) &#123; cache = @(NO); [self.keyPathCache setObject:cache forKey:cacheKey]; return; &#125; else &#123; cache = @(YES); [self.keyPathCache setObject:cache forKey:cacheKey]; &#125; &#125; //keyPath else &#123; BOOL flag = YES; for (NSInteger i = 0; i &lt; keyPaths.count - 1; ++i) &#123; NSString *key = keyPaths[i]; SEL selector = NSSelectorFromString(key); if ([lastObj respondsToSelector:selector]) &#123; lastObj = [lastObj valueForKey:key]; &#125; else &#123; flag = NO; break; &#125; &#125; if (flag) &#123; flag = [lastObj respondsToSelector:NSSelectorFromString(keyPaths.lastObject)]; &#125; cache = @(flag); [self.keyPathCache setObject:cache forKey:cacheKey]; if (flag == NO) &#123; NSLog(@&quot;%@不存在 设置主题失败&quot;, key); return; &#125; &#125; &#125; //key无效 if (cache.boolValue == NO) return; //多参数 if ([key containsString:@&quot;:&quot;]) &#123; NSArray *separatedValues = [key componentsSeparatedByString:@&quot;.&quot;]; NSString *method = separatedValues.lastObject; SEL aSEL = NSSelectorFromString(method); //真正发消息的对象 id sendObj = [toObj valueForKeyPath:[key stringByReplacingOccurrencesOfString:[NSString stringWithFormat:@&quot;.%@&quot;, method] withString:@&quot;&quot;]]; NSArray *valueArr = [obj isKindOfClass:[NSArray class]] ? obj : @[obj]; YYClassMethodInfo *info = [[YYClassMethodInfo alloc] initWithMethod:class_getInstanceMethod([sendObj class], aSEL)]; //冒号之后的参数为实际参数 NSArray &lt;NSString *&gt;*argumentTypeEncodings = ^&#123; NSInteger index = [info.argumentTypeEncodings indexOfObject:@&quot;:&quot;]; if (index != NSNotFound) &#123; return (NSArray *)[info.argumentTypeEncodings subarrayWithRange:NSMakeRange(index + 1, info.argumentTypeEncodings.count - index - 1)]; &#125; return @[]; &#125;(); //参数个数和key的方法不一致 if (argumentTypeEncodings.count != valueArr.count) &#123; return; &#125; NSMethodSignature *sign = [sendObj methodSignatureForSelector:aSEL]; NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:sign]; invocation.target = sendObj; invocation.selector = aSEL; for (NSInteger idx1 = 0; idx1 &lt; argumentTypeEncodings.count; ++idx1) &#123; id obj1 = valueArr[idx1]; id tempObj = [self converValueWithObj:obj1]; YYEncodingType encodingType = YYEncodingGetType(argumentTypeEncodings[idx1].UTF8String); switch (encodingType) &#123; case YYEncodingTypeBool: &#123; BOOL aValue = [tempObj boolValue]; [invocation setArgument:&amp;aValue atIndex:idx1 + 2]; &#125; break; case YYEncodingTypeInt8: &#123; char aValue = [tempObj charValue]; [invocation setArgument:&amp;aValue atIndex:idx1 + 2]; &#125; break; case YYEncodingTypeUInt8: &#123; unsigned char aValue = [tempObj unsignedCharValue]; [invocation setArgument:&amp;aValue atIndex:idx1 + 2]; &#125; break; case YYEncodingTypeInt16: &#123; short aValue = [tempObj shortValue]; [invocation setArgument:&amp;aValue atIndex:idx1 + 2]; &#125; break; case YYEncodingTypeUInt16: &#123; unsigned short aValue = [tempObj unsignedShortValue]; [invocation setArgument:&amp;aValue atIndex:idx1 + 2]; &#125; break; case YYEncodingTypeInt32: &#123; int32_t aValue = [tempObj intValue]; [invocation setArgument:&amp;aValue atIndex:idx1 + 2]; &#125; break; case YYEncodingTypeUInt32: &#123; uint32_t aValue = [tempObj intValue]; [invocation setArgument:&amp;aValue atIndex:idx1 + 2]; &#125; break; case YYEncodingTypeInt64: &#123; long long aValue = [tempObj longLongValue]; [invocation setArgument:&amp;aValue atIndex:idx1 + 2]; &#125; break; case YYEncodingTypeUInt64: &#123; unsigned long long aValue = [tempObj unsignedLongLongValue]; [invocation setArgument:&amp;aValue atIndex:idx1 + 2]; &#125; break; case YYEncodingTypeFloat: &#123; float aValue = [tempObj floatValue]; [invocation setArgument:&amp;aValue atIndex:idx1 + 2]; &#125; break; case YYEncodingTypeDouble: &#123; double aValue = [tempObj doubleValue]; [invocation setArgument:&amp;aValue atIndex:idx1 + 2]; &#125; break; case YYEncodingTypeLongDouble: &#123; long double aValue = [tempObj doubleValue]; [invocation setArgument:&amp;aValue atIndex:idx1 + 2]; &#125; break; case YYEncodingTypeObject: &#123; [invocation setArgument:&amp;tempObj atIndex:idx1 + 2]; &#125; break; default: break; &#125; &#125; //调用 [invocation invoke]; &#125; else &#123; [toObj setValue:[self converValueWithObj:obj] forKeyPath:key]; &#125; &#125;];&#125; 这么长一段代码，我都不想看😑，幸好还记得怎么实现的。按照上面我们说的，应该非常简单才对，但是实际上还要处理一些其他情况。举个例子，UIButton 在设置图片、文字颜色等属性的时候需要带上 UIControlState，那就需要传两个参数。Plist可以把这种多参数保存为数组，但是KVC就没办法做到赋值了，这时候就要借助到OC的运行时了。 我们知道，OC\b的方法调用，本质都是发送消息，而消息的参数是不确定的，所以我们可以借助底层提供的 NSInvocation 这种通过方法签名发消息的类。如果了解过OC的消息转发机制的同学，应该见过这个类。它其实是一个调用器，设置了方法签名，再设置了参数就可以像普通消息发送了。方法名我们定义成配置的 key，多参数就和OC的方法名一样，用”:”隔开，类似这样：setImage:forState，value 是一个数组。实现用了YYKit的一些方法，只是写起来简单一些，内部就是调用runtime的API，这样就做到了多参数的兼容。 然而实际使用的时候，其实很麻烦。有一个比较巧妙的方式是通过分类去添加参数。比如 UIButton 的 setImage:forState，我们可以添加这些分类：123@property (nonatomic, strong) UIImage *jh_normalImg;@property (nonatomic, strong) UIImage *jh_hightlightedImg;... 实现是这样：123456789101112131415- (void)setJh_normalImg:(UIImage *)jh_normalImg &#123; [self setImage:jh_normalImg forState:UIControlStateNormal];&#125;- (UIImage *)jh_normalImg &#123; return [self imageForState:UIControlStateNormal];&#125;- (void)setJh_hightlightedImg:(UIImage *)jh_hightlightedImg &#123; [self setImage:jh_hightlightedImg forState:UIControlStateHighlighted];&#125;- (UIImage *)jh_hightlightedImg &#123; return [self imageForState:UIControlStateHighlighted];&#125; 通过分类指定其它的参数就可以像单个参数那样使用了。 至于自动调用，其实很简单。我们给 NSObject 添加一个分类，实现如下：12345678910111213141516171819202122@implementation NSObject (JHThemeManager)- (void)jh_updateTheme &#123; [self jh_updateThemeByKey:nil];&#125;- (void)jh_updateThemeByKey:(NSString *)key &#123; [self jh_updateThemeByKey:key block:nil];&#125;- (void)jh_updateThemeByKey:(NSString *)key block:(JHThemeCustomAction)block &#123; [self jh_updateThemeByKey:key theme:nil block:block];&#125;- (void)jh_updateThemeByKey:(NSString *)key theme:(NSString *)theme block:(JHThemeCustomAction)block &#123; [[JHThemeManager shareThemeManager] updateObjStyleWithCurrentTheme:self themeKey:key themeName:theme block:block];&#125;@end 其实也只不过是对 [[JHThemeManager shareThemeManager] updateObjStyleWithCurrentTheme:self themeKey:key themeName:theme block:block]; 的封装，这个key\b是配置里的 key，一般定义成类名。theme 就是主题的名字，传 nil的话就获取当前主题。然后创建在你的控制器基类、各种View的基类中合适的时机调用 - (void)jh_updateTheme 就会自动在生成时进行主题设置。 配置文件是这样的： 结尾实际使用中，这个轮子并不太方便。一是因为代码都在 Plist 里，\b不能非常直观的看到样式的设置过程。而且要求key与类中的属性，代码一旦有修改，Plist也需要做修改。最重要的一点是 Value 字符串的书写不能出错，但这是不太容易的，因为人就是个Bug。 比较好的解决方式就是写个GUI工具，能浏览和生成配置，而不是通过手工添加。","categories":[],"tags":[]},{"title":"UITableView+FDTemplateLayoutCell计算行高一些缺陷的解决方法","slug":"UITableView-FDTemplateLayoutCell计算行高一些缺陷的解决方法","date":"2018-08-25T18:27:38.000Z","updated":"2018-12-15T18:00:02.338Z","comments":true,"path":"2018/08/26/UITableView-FDTemplateLayoutCell计算行高一些缺陷的解决方法/","link":"","permalink":"https://sunsx9316.github.io/2018/08/26/UITableView-FDTemplateLayoutCell计算行高一些缺陷的解决方法/","excerpt":"","text":"前言UITableView动态行高一直是iOS的一个经典问题，在没有AutoLayout的时代，只能自己计算frame，然后返回给代理，非常痛苦。到了AutoLayout的时代，布局就变得简单多了，甚至于通过系统提供的API都能自动计算出行高。 UITableView+FDTemplateLayoutCell就是sunnyxx大大的一个自动计算行高的框架。只要布局正确，通过它可以自动计算并缓存行高，非常方便。不过在使用上发现一些问题，也尝试去解决了。 过程需求是这样的，一个类似微博的页面，像这样： 这应该是比较经典的布局，内容和图片都是不确定的，行高要根据实际数据计算。九宫格实现方式有很多，我这里是通过UICollectionView去实现的。这样的一个好处就是UICollectionView的高度可以通过它的collectionViewLayout对象获取，啥都不用算。不过会有一个问题，UICollectionView继承自UIScrollView，它的高度没法按照内容来全显示。所以即使布局正确，通过AutoLayout来计算行高也是不包括UICollectionView的，这个问题同样反映在一些UIView控件上。 这就十分蛋疼了，难道还要回到手算frame的时代？当然不是，是我还写啥博客。 我说下解决的几个方法。 方法一（不推荐）：手动设置collectionView的高度，可以通过代码或者xib来设置，我这里是xib。 像这样手动指定collectionView的高度，然后赋值数据源的时候更新collectionView高度约束就可以了，让它的高度等于它的contentSize.height，这样就能全部显示了，其它UIView控件也能这么解决。但是这样在计算行高的时候会抛出非常多异常，都是约束的问题。我不是很清楚这是什么原因，按理说计算再后，赋值在前，应该不会这样。而且显示会出一些问题，计算的行高会不正确，有些许误差。 方法二（推荐）：既然不能通过这种方式，那就绕个弯吧。去掉高度约束，计算出来的高就不包含collectionView的高。然后再手动加上collectionView的高返回给代理不就行了。不过看下UITableView+FDTemplateLayoutCell的拓展方法：12- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifierconfiguration:(void (^)(id cell))configuration; 只有一个设置cell数据源的block，正常情况下我们只需要把cell换成我们自己的类，然后赋值模型就行，缓存之类的框架会自动处理好。虽然我们可以获取到缓存高度之后再加上collectionView的高，但是这样还叫啥缓存，缓存就是不需要计算，直接取到就能用，那怎么办呢？虽然可以通过Method Swizzling黑魔法交换方法实现，但是这并不是最优方法，往往是一些莫名其妙的bug的源泉，作为开发者应该尽量避免这种方式。所以最后我选择了通过分类的方式。思路是在框架计算完高度之后通过block返回，我们自行处理行高，加加减减，然后返回高度让框架缓存。具体代码：我们参考下框架这个方法的实现1234567891011121314151617181920- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifiercacheByIndexPath:(NSIndexPath *)indexPathconfiguration:(void (^)(id cell))configuration &#123;if (!identifier || !indexPath) &#123;return 0;&#125;//命中缓存if ([self.fd_indexPathHeightCache existsHeightAtIndexPath:indexPath]) &#123;[self fd_debugLog:[NSString stringWithFormat:@&quot;hit cache by index path[%@:%@] - %@&quot;, @(indexPath.section), @(indexPath.row), @([self.fd_indexPathHeightCache heightForIndexPath:indexPath])]];return [self.fd_indexPathHeightCache heightForIndexPath:indexPath];&#125;//计算行高CGFloat height = [self fd_heightForCellWithIdentifier:identifier configuration:configuration];[self.fd_indexPathHeightCache cacheHeight:height byIndexPath:indexPath];[self fd_debugLog:[NSString stringWithFormat: @&quot;cached by index path[%@:%@] - %@&quot;, @(indexPath.section), @(indexPath.row), @(height)]];return height;&#125; 它先从缓存中寻找行高，命中之后直接返回。否则计算行高，存入缓存，然后返回。所以很简单，我们可以直接复制它的代码。写一个带编辑行高功能的方法：12345678910111213141516171819202122232425262728293031typedef CGFloat(^editCellHeightAction)(id cell, CGFloat cellHeight);- (CGFloat)jh_heightForCellWithIdentifier:(NSString *)identifiercacheByIndexPath:(NSIndexPath *)indexPathconfiguration:(void (^)(id cell))configurationeditAction:(editCellHeightAction)editAction &#123;if (!identifier || !indexPath) &#123;return 0;&#125;// Hit cacheif ([self.fd_indexPathHeightCache existsHeightAtIndexPath:indexPath]) &#123;[self fd_debugLog:[NSString stringWithFormat:@&quot;hit cache by index path[%@:%@] - %@&quot;, @(indexPath.section), @(indexPath.row), @([self.fd_indexPathHeightCache heightForIndexPath:indexPath])]];return [self.fd_indexPathHeightCache heightForIndexPath:indexPath];&#125;CGFloat height = 0;//获取缓存中的cellUITableViewCell *templateLayoutCell = [self fd_templateCellForReuseIdentifier:identifier];//这里插入编辑行高的代码if (editAction) &#123;height = editAction(templateLayoutCell, [self fd_heightForCellWithIdentifier:identifier configuration:configuration]);&#125;else &#123;height = [self fd_heightForCellWithIdentifier:identifier configuration:configuration];&#125;[self.fd_indexPathHeightCache cacheHeight:height byIndexPath:indexPath];[self fd_debugLog:[NSString stringWithFormat: @&quot;cached by index path[%@:%@] - %@&quot;, @(indexPath.section), @(indexPath.row), @(height)]];return height;&#125;&#125; 使用起来像这样：1234567891011- (CGFloat)tableView:(UITableView *)tableViewheightForRowAtIndexPath:(NSIndexPath *)indexPath &#123;return [tableView jh_heightForCellWithIdentifier:@&quot;MineCell&quot; cacheByIndexPath:indexPath configuration:^(HeSquareCell *cell) &#123;//正常赋值数据源cell.model = self.model;&#125; editAction:^CGFloat(MineCell *cell, CGFloat cellHeight) &#123;//cellHeight是上面的block计算后回调过来的 所以直接加上额外的高度即可//因为缓存的关系这里只会走一次 所以可以放心写return cellHeight + [cell collectionViewHeightWithModel:self.model];&#125;];&#125; 这样高度就能正常显示了，而且也不会抛异常，还能享受框架带来的便利。UITableView+FDTemplateLayoutCell的接口设计很易于拓展，所以写起来很简单。还有个问题，我发现在使用这个框架的时候，如果_tableView.tableFooterView = [[UIView alloc] init];这句话写在注册cell之前，程序会crash，不造为啥。如果各位有更好的解决思路或者文中有错误的地方欢迎给我留言。","categories":[],"tags":[]},{"title":"我的第一篇博客","slug":"第一篇博客","date":"2018-08-25T16:55:41.870Z","updated":"2018-08-25T16:55:41.870Z","comments":true,"path":"2018/08/26/第一篇博客/","link":"","permalink":"https://sunsx9316.github.io/2018/08/26/第一篇博客/","excerpt":"","text":"\b最近决定要开始写博客了，打算先把简书的搬过来。这一年接触了很多东西，觉得需要记录下来，自己搭博客还蛮有意思的:)","categories":[],"tags":[]}]}