<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jim Huang的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/sunsx9316/"/>
  <updated>2018-12-15T13:19:30.981Z</updated>
  <id>https://github.com/sunsx9316/</id>
  
  <author>
    <name>Jim Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>对于订阅和反订阅的一些思考</title>
    <link href="https://github.com/sunsx9316/2018/12/15/%E5%AF%B9%E4%BA%8E%E8%AE%A2%E9%98%85%E5%92%8C%E5%8F%8D%E8%AE%A2%E9%98%85%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <id>https://github.com/sunsx9316/2018/12/15/对于订阅和反订阅的一些思考/</id>
    <published>2018-12-15T07:50:44.000Z</published>
    <updated>2018-12-15T13:19:30.981Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为项目的一些历史原因，最近在进行重构，碰到了一些比较核心的订阅部分，写出来记录一下。</p><p>订阅这个概念我是首先在RAC里见到。在响应式编程里一切都是数据流，RAC在实现上创建了信号和订阅的概念，你可以监听信号的变化，iOS底层是通过KVO和运行时实现的。KVO大家应该比较熟悉，网上说它原理的文章太多了，大致就是通过运行时动态创建子类，hook属性的set方法，在值改变的时候回调，不过我们需要自己手动移除监听，否则会存在内存问题，这个设计饱受诟病。从Swift 4.0开始，KVO有了一种新的写法。API是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func observe&lt;Value&gt;(_ keyPath: KeyPath&lt;Observer, Value&gt;,</span><br><span class="line">  options: NSKeyValueObservingOptions = default,</span><br><span class="line">  changeHandler: @escaping (Observer, NSKeyValueObservedChange&lt;Value&gt;) -&gt; Void) -&gt; NSKeyValueObservation</span><br></pre></td></tr></table></figure></p><p>然后我们就可以这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class TestObj: NSObject &#123;</span><br><span class="line">    @objc dynamic var str = &quot;&quot;</span><br><span class="line"></span><br><span class="line">    var observer: NSKeyValueObservation?</span><br><span class="line"></span><br><span class="line">    func testKVO() &#123;</span><br><span class="line">        self.observer = self.observe(\.str, options: .new) &#123; (obj, values) in</span><br><span class="line">            print(values)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里需要注意的是必须创建一个强引用持有返回的对象，否则监听事件就无效了。这个对象的类型是<code>NSKeyValueObservation</code>，结构很简单，定义是这样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class NSKeyValueObservation : NSObject &#123;</span><br><span class="line"></span><br><span class="line">    ///invalidate() will be called automatically when an NSKeyValueObservation is deinited</span><br><span class="line">    public func invalidate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释说这个对象在释放的时候会自动解除引用，也就是说不需要我们自己手动移除KVO监听了，监听事件和对象的生命周期绑定。RAC的里的<code>RACKVOTrampoline</code>就是这种实现的一个例子。</p><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>先说说业务场景。App在某些页面需要给服务器发送指令，请求返回相应的数据。项目里因为对数据实时性要求比较高，而且为了统一前端和移动端，使用了<code>WebSocket</code>协议。指令存在很多种类型，有针对单个Tab的，或者详情页中针对单个币种的，他们之间互不影响。但是和订阅一样，有订阅就有反订阅，所以在不需要的时候需要向服务器发送取消的指令。所以我希望这里的指令能像上面说的订阅模型一样，在对象销毁的时候自动发送取消指令。RAC有一套比较完整的订阅模式，但是依赖比较严重，项目中希望慢慢移除掉它，所以实现了一个更贴近业务轻量的框架。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>其实指令大致就分为两类，一种是tab指令，一种是单个币种的指令。单就这两个就没什么好说的了，无非就是页面出现的时候创建指令对象，发指令给服务器，页面销毁也就发送取消的指令给服务器，中断数据传输。<br>唯一一个复杂的点在单个币种指令的集合。因为有一种业务场景是这样的，本地允许用户添加自选，不上传服务器。那么服务器没办法知道用户的自选列表里有什么，传什么数据就需要App自己指定。当时为了赶需求，这种方式就直接使用了单个指令，有多少个自选币种，就创建多少个指令对象。虽然简单粗暴，但是在取消的时候就有一些麻烦了。后来重构，发现确实也只有这种方式可行，这和业务场景有关。比如我从本地自选A页面跳转到某个需要发送单个指令的页面B，这时候订阅对象应该是复用的，因为从B页面回到A的时候，单个指令也并不应该销毁，因为A页面依然持有它。当时为了这个问题头疼了很久，后来恍然大悟，这不就是和MRC原理差不多嘛。</p><p>明白了之后就很简单了。</p><ol><li>首先在自选列表A页面需要发送指令的时候由一个全局的管理器创建一个指令对象给A页面持有，因为列表允许多个单指令集合，所以管理器需要把这些单个对象组合成一个集合C返回。</li><li>跳转到B页面时，同样需要通过管理器创建指令，管理器发现这个单指令存在，那么就不要创建了，返回它的引用，这时候集合C的引用计数就是2。</li><li>B页面在销毁的时候引用计数-1，但是因为A页面的持有，集合C实际上引用计数还是1，不会释放，也就不会发送取消指令。</li></ol><p>看似可行的方案，实践中碰上了一些问题。按照MRC的规则，谁创建，谁释放，那么A页面在销毁的时候按理说集合C也要销毁，但是管理器也需要持有集合C，这样其它页面来请求指令的时候才能知道应该创建新的指令对象还是应该返回引用。但是管理器不应该强持有集合C，不然集合C就永远无法释放了。所以管理器在持有集合C的时候需要弱引用。这里用到了<code>NSHashTable</code>，它的用法和<code>NSArray</code>很相似，但是<code>NSHashTable</code>可以持有弱引用的对象。</p><p>所以博客到这里就写完了吗？当然没有。还有一个最大的发送取消集合C的指令的问题。服务器提供了一个批量取消单指令的指令，很适合集合C的场景。想法很简单，在集合C销毁的时候把它持有的单指令批量取消，就不需要一个个的去发送取消的指令了。那么问题来了，集合C怎么知道哪些单个指令需要取消，哪些不需要呢。而且集合C必须强持有它的单个指令，按照释放顺序，在集合C走到<code>deinit</code>方法的时候，它的属性是还能访问的。所以我们需要让集合C的单指令提前释放，并且还需要知道哪些单个指令需要发送取消指令，哪些不需要。核心代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class ListSubscribeObservation &#123;</span><br><span class="line">  //单订阅的数组</span><br><span class="line">  var children: [SingleSubscribeObservation]?</span><br><span class="line"></span><br><span class="line">  deinit() &#123;</span><br><span class="line">        //持有一份单指令的弱引用 然后让单指令集合提前释放</span><br><span class="line">        //如果弱引用还存在 那么说明还有地方在强应用这个单指令 那么不应该把它取消</span><br><span class="line"></span><br><span class="line">        let obsTable = NSHashTable&lt;SingleSubscribeObservation&gt;(options: [.weakMemory, .objectPointerPersonality], capacity: 0)</span><br><span class="line">        //要发送给服务器的指令集</span><br><span class="line">        var subKeys = [String]()</span><br><span class="line">        autoreleasepool &#123;</span><br><span class="line">            while let obj = self.children?.popLast() &#123;</span><br><span class="line">                obsTable.add(obj)</span><br><span class="line">                //这个标记用于表示是否应该发送取消指令</span><br><span class="line">                item.autoUnsub = false</span><br><span class="line">                subKeys.append(obj.value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //走到这里单指令集合应该已经被提前释放了 剩下的则不应该发送指令 将它移除出数组</span><br><span class="line">        for item in obsTable.objectEnumerator() &#123;</span><br><span class="line">            if let item = item as? SingleSubscribeObservation &#123;</span><br><span class="line">                //从批量释放中移除</span><br><span class="line">                if subKeys.contains(item.value) &#123;</span><br><span class="line">                    //恢复单订阅自动释放</span><br><span class="line">                    item.autoUnsub = true</span><br><span class="line">                    subKeys.remove(item.value)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if subKeys.count &gt; 0 &#123;</span><br><span class="line">          //发送订阅指令</span><br><span class="line">            let ws = WebSocket.shared</span><br><span class="line">            ws.removeKeys(subKeys)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>但是实际上在某些时候即使这样写，<code>children</code>仍然会在这个对象之后释放，所以最后的办法是在业务层加了延迟发送指令的代码。因为<code>children</code>最后一定会释放，它内部的单个指令也会快速释放，但是走的是单个释放的。所以做法是释放时通过定时器delay个0.1s，如果0.1s内再次走了这个方法，则把上一次的timer取消掉，否则执行批量释放，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class WebSocket &#123;</span><br><span class="line"></span><br><span class="line">// 临时需要移除订阅的数组</span><br><span class="line">private var tempRemoveKeys = Set&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">func removeKeys(_ keys: [String]) &#123;</span><br><span class="line">  if keys.count == 0 &#123;</span><br><span class="line">      return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //使用临时集合保存释放的key</span><br><span class="line">  self.tempRemoveKeys.formUnion(keys)</span><br><span class="line"></span><br><span class="line">  //短时间的批量释放合并到一起处理</span><br><span class="line">  self.removeDelayTimer?.invalidate()</span><br><span class="line">  self.removeDelayTimer = Timer.scheduledTimer(withTimeInterval: 0.2, block: &#123; [weak self] (_) in</span><br><span class="line">      guard let self = self else &#123;</span><br><span class="line">          return</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      let tempKeys = Array(self.tempRemoveKeys)</span><br><span class="line">      //发送取消指令</span><br><span class="line">      self.unsubKeys(tempKeys)</span><br><span class="line">      //移除临时集合</span><br><span class="line">      self.tempRemoveMarkets.removeAll()</span><br><span class="line">      &#125;, repeats: false)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实这个解决方案并不算好，导致调用时机没有按照预期执行的原因有待研究，这里对思考过程做一个记录。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;因为项目的一些历史原因，最近在进行重构，碰到了一些比较核心的订阅部分，写出来记录一下。&lt;/p&gt;
&lt;p&gt;订阅这个概念我是首先在RAC里见到。在
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS的MobileVLCKit框架播放SMB协议视频的问题</title>
    <link href="https://github.com/sunsx9316/2018/08/26/iOS%E7%9A%84MobileVLCKit%E6%A1%86%E6%9E%B6%E6%92%AD%E6%94%BESMB%E5%8D%8F%E8%AE%AE%E8%A7%86%E9%A2%91%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://github.com/sunsx9316/2018/08/26/iOS的MobileVLCKit框架播放SMB协议视频的问题/</id>
    <published>2018-08-26T10:46:38.209Z</published>
    <updated>2018-08-26T10:46:38.209Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://code.videolan.org/videolan/VLCKit" target="_blank" rel="noopener">MobileVLCKit</a>是开源播放器VLC的iOS平台框架，在Mac OS上也有对应的VLCKit，搞直播的同学应该不陌生，不过它其实还是一款强大的本地播放器，支持几乎所有的主流媒体格式。最近在研究app如何浏览电脑上文件，然后直接做到播放视频的功能。用过iOS上的VLC播放器的童鞋应该知道，他能做到扫描本地端口，然后通过输入用户名和密码浏览电脑的文件，点击视频和音频还能直接播放。<br>通过Google知道这里用到一个叫SMB的协议，不光是Mac OS上，Windows和Linux都支持这种协议。只要本地开启SMB的文件共享服务，同一个局域网内的设备就能通过它访问电脑上的文件了。<br>上上<del>gayhub</del>发现了一个SMB的iOS框架，叫<a href="https://github.com/TimOliver/TOSMBClient">TOSMBClient</a>，它将一个C语言的框架封装成了OC的框架。还支持CocoaPods，使用起来非常方便。而<a href="https://code.videolan.org/videolan/VLCKit" target="_blank" rel="noopener">MobileVLCKit</a>原生就支持SMB协议的在线播放。所以解决方案是通过TOSMBClient获取文件列表，VLC播放，想法很美好，但是实际实现还是踩了不少坑。</p><p>先说说SMB的格式，长这样：<code>smb://{hostname}:{password}@{ip}/path</code> 比如桌面上的一个mp4文件就应该长这样：<code>smb://xiaoming:123456@192.168.1.100/xiaoming/Desktop/233.mp4</code><br>hostname是域名，一般创建SMB共享协议的时候，就需要指定。password是密码，ip是服务器的ip。<br><a href="https://github.com/TimOliver/TOSMBClient">TOSMBClient</a>提供了一个登录的类叫<code>TOSMBSession</code>，常用属性是这几个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//服务器域名</span><br><span class="line">@property (nonatomic, copy) NSString *hostName;</span><br><span class="line">//服务器ip</span><br><span class="line">@property (nonatomic, copy) NSString *ipAddress;</span><br><span class="line">//登录的用户名</span><br><span class="line">@property (nonatomic, copy) NSString *userName;</span><br><span class="line">//登录密码</span><br><span class="line">@property (nonatomic, copy) NSString *password;</span><br></pre></td></tr></table></figure></p><p>其中域名和ip可以都设置，也可以只设置其中一个，框架会自动查找。<br>然后通过<code>TOSMBSession</code>提供的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)requestContentsOfDirectoryAtFilePath:(NSString *)path</span><br><span class="line">success:(void (^)(NSArray *files))successHandler</span><br><span class="line"> error:(void (^)(NSError *))errorHandler;</span><br></pre></td></tr></table></figure></p><p>获取文件列表，很简单。返回的files是<code>TOSMBSessionFile</code>类型。它包含基本的文件信息，比如路径，名称，大小。想法挺美好，有URL，直接给VLC播放不就行了，然后就碰到了<strong>第一个坑。</strong><br><code>TOSMBSessionFile</code>提供的路径只是smb格式的一部分，也就只有path部分，所以需要播放还得自己拼接成完整路径。</p><p>拼接好了之后尝试下播放个文件，没带中文的，成功了，高兴之余本着严谨的态度试了下中文路径，结果失败了。NSURL初始化如果包含标准ASCALL以外的字符，会返回nil，这是<strong>第二个坑。</strong></p><p>作为程序员，很自然会想到，URL如果带中文，浏览器会自动做URL转码。所以尝试下转码，发现还是播放失败。这就让我怀疑人生了，怎么肥事？而且连iOS上的VLC的app都有这个问题，这是<strong>第三个坑。</strong></p><p>通过查找API我发现播放器除了通过NSURL初始化，还可以通过NSString初始化，我想，NSURL不让包含中文，NSString总可以吧。结果还是播放失败，神奇的是即使不包含中文，通过NSString初始化还是失败，但是NSURL就可以，这是<strong>第四个坑。</strong></p><p>既然一定要实现功能，那就得搞明白为什么，这时候开源的好处就体现出来了，我看了下<a href="https://code.videolan.org/videolan/VLCKit" target="_blank" rel="noopener">MobileVLCKit</a>的源码，它的媒体类<strong>VLCMedia</strong>是这么写的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithPath:(NSString *)aPath</span><br><span class="line">&#123;</span><br><span class="line">    return [self initWithURL:[NSURL fileURLWithPath:aPath isDirectory:NO]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithURL:(NSURL *)anURL</span><br><span class="line">&#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        const char *url;</span><br><span class="line">        VLCLibrary *library = [VLCLibrary sharedLibrary];</span><br><span class="line">        NSAssert(library.instance, @&quot;no library instance when creating media&quot;);</span><br><span class="line"></span><br><span class="line">        if (([[anURL absoluteString] hasPrefix:@&quot;sftp://&quot;]) ||</span><br><span class="line">            ([[anURL absoluteString] hasPrefix:@&quot;smb://&quot;])) &#123;</span><br><span class="line">            url = [[[anURL absoluteString] stringByRemovingPercentEncoding] UTF8String];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            url = [[anURL absoluteString] UTF8String];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p_md = libvlc_media_new_location(library.instance, url);</span><br><span class="line"></span><br><span class="line">        _metaDictionary = [[NSMutableDictionary alloc] initWithCapacity:3];</span><br><span class="line"></span><br><span class="line">        [self initInternalMediaDescriptor];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，<code>initWithPath:</code>方法把字符串通过<code>fileURLWithPath:isDirectory:</code>方法初始化成URL了，所以smb格式的字符串路径通过这个方法初始化得到的路径肯定是错的，因为它不是标准的本地路径，自然会出现上面神奇的情况。<br>然后看下<code>initWithURL:</code>方法，if语句判断如果包含smb前缀，则做URL解码操作。说明我们的想法是正确的，确实应该对URL进行编码。但是，经过测试编码还是不行，这种情况就很费解了。到现在我还不知道什么原因，因为它自己的APP都有这个问题。不过之后偶然发现了解决方法，很简单<br><strong><br>把URL编码两次即可！！<br>把URL编码两次即可！！<br>把URL编码两次即可！！</strong></p><p>重要的事情说三遍，编码两次之后框架会对URL解码一次，所以得到的URL实际是编码了一次的内容，这样就能播放了，非常神奇，这是<strong>第五个坑。</strong>在这里分享一下给需要的童鞋。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>应该只对<code>path</code>、<code>hostname</code>、<code>password</code>部分做URL两次编码，<code>smb://</code>前缀不需要，否则播放器会无法识别。</p><p>2017.10.16日更新 如果发现拼接之后还是没法播放，大部分是因为VLC的版本比较旧的关系，cocoapods里有最新的unstable版本，用这个，不过这个版本也是最不稳定的。</p><p>2018.7.8日更新 <a href="https://github.com/sunsx9316/SMBPlayerDemo">文章Demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://code.videolan.org/videolan/VLCKit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MobileVLCKit&lt;/a&gt;是开源播放器VLC的iOS平台框架，在Mac OS上也有对应的VLCKit，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>APP切换主题的一些思考</title>
    <link href="https://github.com/sunsx9316/2018/08/26/APP%E5%88%87%E6%8D%A2%E4%B8%BB%E9%A2%98%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <id>https://github.com/sunsx9316/2018/08/26/APP切换主题的一些思考/</id>
    <published>2018-08-26T07:14:17.000Z</published>
    <updated>2018-12-15T13:58:57.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>APP内切换主题是比较常见的需要，蛮早就思考过这个问题。网上也有很多的解决方案，不过本质上其实都类似，无非是两种情况。</p><ul><li>如果需要实现类似手Q那样动态更换主题，那么主题一定是个配置文件，能够从服务器下载。</li><li>如果只要求能更换成本地的几套主题，那只通过代码初始化，写死也是可以的。</li></ul><p>说说两者的优缺点。</p><ul><li>第一种比较灵活，但是引入的配置文件肯定要求格式的通用，毕竟不太可能要求服务端针对不同的设备提供不同的配置。那么很多人或许会选择JSON或者XML之类的格式。这样就会导致可读性不那么好，也不太直观，而且也没办法在编译期就做代码检查。</li><li>第二种对比第一种就更直观，没有什么能比 <code>label.textColor = redColor</code> 这样的代码更易读了吧。同时因为是原生开发，也可以在编译期就做到代码检查，缺点就是灵活性差了些。</li></ul><p>所以要做的其实是选择适合自己的类型，还有如何能更简单的做到切换而已。这个轮子其实并不太适合项目，更多是作为思考。公司项目并不要求做到类似手Q那样动态切换主题，但是为了拓展性，我还是考虑通过配置文件去加载。</p><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>因为写主题配置是十分麻烦的事，我想要做到的效果是只写配置文件，代码里不需要写任何判断和设置的逻辑就能做到自动根据当前主题切换样式。所以要做的事分为以下几步：</p><ol><li>书写配置</li><li>程序读取配置</li><li>代码根据当前主题自动设置样式</li></ol><p>同时配置文件要求可读性良好，就算别人接手了这个模块也不需要熟悉特定的配置书写语法。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>因为是本地使用，那么可以不考虑通用性，为了开发简单，我们使用<code>Plist</code>写配置。为了可读性良好，且尽量不增加学习成本，我想做到最好写在配置里的就是类似 <code>label.textColor = redColor</code> 这样的赋值语句。那能不能做到这一点呢，当然可以，我们可以借助OC的KVC。KVC本身也支持keyPath这样的赋值方式，<code>&quot;label.textColor&quot;</code> 这样的字符串在KVC中会被解析成查找 <code>label</code> 下的 <code>textColor</code> 属性。所以我们在 <code>Plist</code> 里的 <code>key</code>就可以定义成 <code>&quot;label.textColor&quot;</code>，而 <code>value</code>就是颜色。</p><p>那么问题来了，<code>Plist</code> 只支持字符串、数字、日期、二进制流这几种有限的格式，那怎么让它支持颜色呢？很容易联想到颜色16进制的表示方式，比如白色使用16进制表示就是 <code>#FFFFFF</code>，所以直接使用字符串不就好了。但是问题没这么简单。</p><p>一种比较常见的需求是在不同的主题下需要显示不同图片 (比如我们就有白天和黑夜模式，黑夜模式的图片就要求暗一些。小声bb……)，颜色如果使用了 <code>#FFFFFF</code> 这样的方式设置，那么图片怎么办？图片可以根据图片名，但是程序需要知道这个字符串是什么才能把它转成对应的东西，所以就需要定一套简单的规则了。</p><p>字符串非常灵活，任意的组合可以得到完全不同的内容，所以对于这种情况，选择字符串类型是比较合适的。类似编译器，有一套自己的复杂的解析规则，会把字符串转换为语法树。我们不需要这么复杂，只是简单的格式就好，但是可以设计成拥有很强拓展性的模式。所以我们需要定义一些通用的接口，生成一些解析器，这会在第二步详细说明。</p><h3 id="读取配置"><a href="#读取配置" class="headerlink" title="读取配置"></a>读取配置</h3><p>这一步比较重要的是接口的设计，关乎到使用的方便性和未来的拓展性。</p><p>我们接着说第一步末尾说到的解析器。为什么要定义解析器呢？首先每一个 <code>Plist</code>的对象，值传过来都是个字符串，我们要根据里面字符串的格式判断它是应该解析成颜色，或者图片又或者是其它。每种情况都不一样，所以拆分成独立的解析器会更好。不过他们都用一个共同点，遵守同一个协议。协议我们这样定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 解析优先级</span><br><span class="line"></span><br><span class="line"> - JHThemeParserPriorityRequest: 最先解析</span><br><span class="line"> - JHThemeParserPriorityNormal: 普通</span><br><span class="line"> - JHThemeParserPriorityUnimportance: 最后解析</span><br><span class="line"> */</span><br><span class="line">typedef NS_ENUM(NSUInteger, JHThemeParserPriority) &#123;</span><br><span class="line">    JHThemeParserPriorityUnimportance,</span><br><span class="line">    JHThemeParserPriorityNormal,</span><br><span class="line">    JHThemeParserPriorityRequest = 1000,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@class JHTheme;</span><br><span class="line">@protocol JHThemeParserProtocol &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 解析优先级</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, assign, readonly) JHThemeParserPriority priority;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 唯一标识</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, copy, readonly) NSString *identify;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 是否在解析之后直接返回 YES会将解析结果让之后的解析器继续解析</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, assign, readonly) BOOL continueParse;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 是否能解析这个值</span><br><span class="line"></span><br><span class="line"> @param value 值</span><br><span class="line"> @return 是否能解析这个值</span><br><span class="line"> */</span><br><span class="line">- (BOOL)canParseValue:(id)value;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 解析具体实现</span><br><span class="line"></span><br><span class="line"> @param value 值</span><br><span class="line"> @param currentTheme 当前主题</span><br><span class="line"> @return 解析结果</span><br><span class="line"> */</span><br><span class="line">- (id)converValue:(id)value currentTheme:(JHTheme *)currentTheme;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>重要的是这两个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)canParseValue:(id)value;</span><br><span class="line">- (id)converValue:(id)value currentTheme:(JHTheme *)currentTheme;</span><br></pre></td></tr></table></figure></p><p>第一个方法判断这个解析器能否解析这个字符串。</p><ul><li>如果返回 <code>true</code> ， 那么会接着调用<code>converValue:(id)value currentTheme:(JHTheme *)currentTheme</code>，让解析器自己内部进行解析。</li><li>如果返回 <code>false</code>，那么这个解析器就无法解析这个字符串，也不会有之后的调用了。</li></ul><p>举个简单的例子，这是颜色解析器内部的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@implementation JHThemeColorParser</span><br><span class="line">- (BOOL)canParseValue:(NSString *)value &#123;</span><br><span class="line">    if ([value isKindOfClass:[NSString class]] &amp;&amp; ([value hasPrefix:@&quot;c(&quot;] || [value hasPrefix:@&quot;C(&quot;]) &amp;&amp; [value hasSuffix:@&quot;)&quot;]) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)converValue:(NSString *)value currentTheme:(JHTheme *)currentTheme &#123;</span><br><span class="line">    //取出色值</span><br><span class="line">    value = [value substringWithRange:NSMakeRange(2, value.length - 3)];</span><br><span class="line">    NSArray &lt;NSString *&gt;*rgba = [value componentsSeparatedByString:@&quot;,&quot;];</span><br><span class="line">    //16进制</span><br><span class="line">    if (rgba.count == 1) &#123;</span><br><span class="line">        return [UIColor colorWithHexString:value];</span><br><span class="line">    &#125;</span><br><span class="line">    else if (rgba.count &gt;= 3) &#123;</span><br><span class="line">        CGFloat r = 0,g = 0,b = 0,a = 1;</span><br><span class="line">        r = rgba.firstObject.doubleValue / 255.0;</span><br><span class="line">        g = rgba[1].doubleValue / 255.0;</span><br><span class="line">        b = rgba[2].doubleValue / 255.0;</span><br><span class="line">        if (rgba.count &gt;= 4) &#123;</span><br><span class="line">            a = rgba[3].doubleValue;</span><br><span class="line">        &#125;</span><br><span class="line">        return [UIColor colorWithRed:r green:g blue:b alpha:a];</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>首先 <code>- (BOOL)canParseValue:(id)value</code> 这个方法的实现是判断值是否符合规则，这里我定义成符合 <code>c(#FFFFF)</code> 或者 <code>c(255,255,255)</code> 格式的字符串就可以解析。前者是颜色的16进制表示法，后者是通过指定RGB数字的颜色表示法。而下面只是对这个解析格式的实现而已。这样做的好处是如果想定义一套比较复杂的解析规则，只要实现协议，自己写解析逻辑就好了。比如除了颜色的，我还实现了一些类似宏的解析逻辑。像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)canParseValue:(NSString *)value &#123;</span><br><span class="line">    if ([value isKindOfClass:[NSString class]] &amp;&amp; ([value hasPrefix:@&quot;d(&quot;] || [value hasPrefix:@&quot;D(&quot;]) &amp;&amp; [value hasSuffix:@&quot;)&quot;]) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)converValue:(NSString *)value currentTheme:(JHTheme *)currentTheme &#123;</span><br><span class="line">    NSString *tempStr = [[value substringWithRange:NSMakeRange(2, value.length - 3)] stringByTrim];</span><br><span class="line">    NSDictionary *mapDic = currentTheme.defineMap;</span><br><span class="line">    id map = mapDic[tempStr];</span><br><span class="line">    if (map) &#123;</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)continueParse &#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (JHThemeParserPriority)priority &#123;</span><br><span class="line">    return JHThemeParserPriorityRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>场景是APP有一个主题色，如果按照上面只是通过指定颜色去写，那就会很麻烦，而且一旦主题色更换，也要全局修改。这个宏解析器就定义了一种字符串格式像这样 <code>d(mainColor)</code>。配置文件有一个独立的”宏字典”，解析器取出 <code>mainColor</code> 然后在”宏字典”里查找 <code>mainColor</code>对应的 <code>value</code>是什么，这个 <code>value</code> 我只要定义成<code>c(#FFFFF)</code> 或者其它解析器可以解析的格式，就可以做到类似宏定义的替换效果。需要注意的是 <code>- (BOOL)continueParse</code> 需要返回 <code>YES</code>，这样解析的结果才能返回给其它的解析器继续解析。</p><p>所以可以看到，这样是非常灵活的。</p><h3 id="自动设置样式"><a href="#自动设置样式" class="headerlink" title="自动设置样式"></a>自动设置样式</h3><p>这一步其实相对来说比较容易了，但是也有不少值得说的地方。我这里定义了一个叫 <code>themeManager</code> 的主题管理类。接口这样设计：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 自定义操作block</span><br><span class="line"></span><br><span class="line"> @param aObj 更改的对象</span><br><span class="line"> @param key 键</span><br><span class="line"> @param value 值</span><br><span class="line"> @return 自定义更改的对象</span><br><span class="line"> */</span><br><span class="line">typedef id(^JHThemeCustomAction)(id aObj, NSString *key, id value);</span><br><span class="line"></span><br><span class="line">@class JHThemeManager;</span><br><span class="line">@protocol JHThemeManagerObserver&lt;NSObject&gt;</span><br><span class="line">@optional</span><br><span class="line">//主题改变回调</span><br><span class="line">- (void)themeManager:(JHThemeManager *)themeManager didChangeTheme:(JHTheme *)theme;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface JHThemeManager : NSObject</span><br><span class="line">+ (instancetype)shareThemeManager;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong, readonly) JHTheme *currentTheme;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 注册自定义解析器</span><br><span class="line"></span><br><span class="line"> @param parserClass 解析器需要实现 JHThemeParserProtocol接口</span><br><span class="line"> */</span><br><span class="line">- (void)registerParser:(Class)parserClass;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 添加单个主题</span><br><span class="line"></span><br><span class="line"> @param theme 主题对象</span><br><span class="line"> */</span><br><span class="line">- (void)addTheme:(JHTheme *)theme;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 添加多个主题</span><br><span class="line"></span><br><span class="line"> @param themes 主题数组</span><br><span class="line"> */</span><br><span class="line">- (void)addThemes:(NSArray &lt;JHTheme *&gt;*)themes;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 根据主题名称更改当前主题</span><br><span class="line"></span><br><span class="line"> @param themeName 主题名称</span><br><span class="line"> */</span><br><span class="line">- (void)updateThemeByName:(NSString *)themeName;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 根据当前主题更新对象的样式</span><br><span class="line"></span><br><span class="line"> @param obj 对象</span><br><span class="line"> @param themeKey 主题下的Key 空则为obj的类名</span><br><span class="line"> @param block 自定义操作</span><br><span class="line"> */</span><br><span class="line">- (void)updateObjStyleWithCurrentTheme:(id)obj</span><br><span class="line">                              themeKey:(NSString *)themeKey</span><br><span class="line">                                 block:(JHThemeCustomAction)block;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 根据当前主题更新对象的样式</span><br><span class="line"></span><br><span class="line"> @param obj 对象</span><br><span class="line"> @param themeKey 主题下的Key 空则为obj的类名</span><br><span class="line"> @param themeName 主题名称</span><br><span class="line"> @param block 自定义操作</span><br><span class="line"> */</span><br><span class="line">- (void)updateObjStyleWithCurrentTheme:(id)obj</span><br><span class="line">                              themeKey:(NSString *)themeKey</span><br><span class="line">                             themeName:(NSString *)themeName</span><br><span class="line">                                 block:(JHThemeCustomAction)block;</span><br><span class="line"></span><br><span class="line">- (void)addObserver:(id&lt;JHThemeManagerObserver&gt;)observer;</span><br><span class="line">- (void)removeObserver:(id&lt;JHThemeManagerObserver&gt;)observer;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><code>- (void)registerParser:(Class)parserClass</code> 注册的是遵守了解析器协议的类，只有注册了才支持解析这种类型的字符串。内部实现是通过数组保存示例，解析的时候根据优先级循环调用已经注册的解析器进行解析。</p><p>然后重点是自动。因为我们的 <code>key</code> 是 <code>keyPath</code>的形式，所以直接通过KVC把解析结果赋值就行。</p><p>实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line">- (void)updateObjStyleWithCurrentTheme:(id)toObj</span><br><span class="line">                              themeKey:(NSString *)themeKey</span><br><span class="line">                             themeName:(NSString *)themeName</span><br><span class="line">                                 block:(JHThemeCustomAction)block &#123;</span><br><span class="line">    if (toObj == nil) return;</span><br><span class="line"></span><br><span class="line">    if (themeKey.length == 0) &#123;</span><br><span class="line">        themeKey = NSStringFromClass([toObj class]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    JHTheme *aTheme = nil;</span><br><span class="line">    if (themeName.length == 0) &#123;</span><br><span class="line">        aTheme = self.currentTheme;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        aTheme = [self themeByName:themeName];</span><br><span class="line">    &#125;</span><br><span class="line">    //获取当前主题所有存储的内容</span><br><span class="line">    NSDictionary *content = aTheme.content[themeKey];</span><br><span class="line">    if ([content isKindOfClass:[NSDictionary class]] == NO) return;</span><br><span class="line"></span><br><span class="line">    [content enumerateKeysAndObjectsUsingBlock:^(NSString * _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123;</span><br><span class="line"></span><br><span class="line">        //自定义修改</span><br><span class="line">        if (block) &#123;</span><br><span class="line">            obj = block(toObj, key, [self converValueWithObj:obj]);</span><br><span class="line">            if (obj == nil) return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NSString *cacheKey = [themeKey stringByAppendingFormat:@&quot;.%@&quot;, key];</span><br><span class="line">        NSNumber *cache = [self.keyPathCache objectForKey:cacheKey];</span><br><span class="line">        //没有缓存过</span><br><span class="line">        if (cache == nil) &#123;</span><br><span class="line">            NSArray &lt;NSString *&gt;*keyPaths = [key componentsSeparatedByString:@&quot;.&quot;];</span><br><span class="line"></span><br><span class="line">            id lastObj = toObj;</span><br><span class="line"></span><br><span class="line">            //单个key</span><br><span class="line">            if (keyPaths.count == 1) &#123;</span><br><span class="line">                //当前key不存在</span><br><span class="line">                BOOL exist = [lastObj respondsToSelector:NSSelectorFromString(keyPaths.firstObject)];</span><br><span class="line">                NSAssert(exist, @&quot;%@不存在 设置主题失败&quot;, key);</span><br><span class="line"></span><br><span class="line">                if (exist == false) &#123;</span><br><span class="line">                    cache = @(NO);</span><br><span class="line">                    [self.keyPathCache setObject:cache forKey:cacheKey];</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    cache = @(YES);</span><br><span class="line">                    [self.keyPathCache setObject:cache forKey:cacheKey];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //keyPath</span><br><span class="line">            else &#123;</span><br><span class="line">                BOOL flag = YES;</span><br><span class="line">                for (NSInteger i = 0; i &lt; keyPaths.count - 1; ++i) &#123;</span><br><span class="line">                    NSString *key = keyPaths[i];</span><br><span class="line">                    SEL selector = NSSelectorFromString(key);</span><br><span class="line">                    if ([lastObj respondsToSelector:selector]) &#123;</span><br><span class="line">                        lastObj = [lastObj valueForKey:key];</span><br><span class="line">                    &#125;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        flag = NO;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (flag) &#123;</span><br><span class="line">                    flag = [lastObj respondsToSelector:NSSelectorFromString(keyPaths.lastObject)];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                cache = @(flag);</span><br><span class="line">                [self.keyPathCache setObject:cache forKey:cacheKey];</span><br><span class="line">                if (flag == NO) &#123;</span><br><span class="line">                    NSLog(@&quot;%@不存在 设置主题失败&quot;, key);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //key无效</span><br><span class="line">        if (cache.boolValue == NO) return;</span><br><span class="line"></span><br><span class="line">        //多参数</span><br><span class="line">        if ([key containsString:@&quot;:&quot;]) &#123;</span><br><span class="line">            NSArray *separatedValues = [key componentsSeparatedByString:@&quot;.&quot;];</span><br><span class="line">            NSString *method = separatedValues.lastObject;</span><br><span class="line">            SEL aSEL = NSSelectorFromString(method);</span><br><span class="line">            //真正发消息的对象</span><br><span class="line">            id sendObj = [toObj valueForKeyPath:[key stringByReplacingOccurrencesOfString:[NSString stringWithFormat:@&quot;.%@&quot;, method] withString:@&quot;&quot;]];</span><br><span class="line"></span><br><span class="line">            NSArray *valueArr = [obj isKindOfClass:[NSArray class]] ? obj : @[obj];</span><br><span class="line">            YYClassMethodInfo *info = [[YYClassMethodInfo alloc] initWithMethod:class_getInstanceMethod([sendObj class], aSEL)];</span><br><span class="line">            //冒号之后的参数为实际参数</span><br><span class="line">            NSArray &lt;NSString *&gt;*argumentTypeEncodings = ^&#123;</span><br><span class="line">                NSInteger index = [info.argumentTypeEncodings indexOfObject:@&quot;:&quot;];</span><br><span class="line">                if (index != NSNotFound) &#123;</span><br><span class="line">                    return (NSArray *)[info.argumentTypeEncodings subarrayWithRange:NSMakeRange(index + 1, info.argumentTypeEncodings.count - index - 1)];</span><br><span class="line">                &#125;</span><br><span class="line">                return @[];</span><br><span class="line">            &#125;();</span><br><span class="line"></span><br><span class="line">            //参数个数和key的方法不一致</span><br><span class="line">            if (argumentTypeEncodings.count != valueArr.count) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            NSMethodSignature *sign = [sendObj methodSignatureForSelector:aSEL];</span><br><span class="line">            NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:sign];</span><br><span class="line">            invocation.target = sendObj;</span><br><span class="line">            invocation.selector = aSEL;</span><br><span class="line"></span><br><span class="line">            for (NSInteger idx1 = 0; idx1 &lt; argumentTypeEncodings.count; ++idx1) &#123;</span><br><span class="line">                id obj1 = valueArr[idx1];</span><br><span class="line">                id tempObj = [self converValueWithObj:obj1];</span><br><span class="line">                YYEncodingType encodingType = YYEncodingGetType(argumentTypeEncodings[idx1].UTF8String);</span><br><span class="line">                switch (encodingType) &#123;</span><br><span class="line">                    case YYEncodingTypeBool:</span><br><span class="line">                    &#123;</span><br><span class="line">                        BOOL aValue = [tempObj boolValue];</span><br><span class="line">                        [invocation setArgument:&amp;aValue atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case YYEncodingTypeInt8:</span><br><span class="line">                    &#123;</span><br><span class="line">                        char aValue = [tempObj charValue];</span><br><span class="line">                        [invocation setArgument:&amp;aValue atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case YYEncodingTypeUInt8:</span><br><span class="line">                    &#123;</span><br><span class="line">                        unsigned char aValue = [tempObj unsignedCharValue];</span><br><span class="line">                        [invocation setArgument:&amp;aValue atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case YYEncodingTypeInt16:</span><br><span class="line">                    &#123;</span><br><span class="line">                        short aValue = [tempObj shortValue];</span><br><span class="line">                        [invocation setArgument:&amp;aValue atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case YYEncodingTypeUInt16:</span><br><span class="line">                    &#123;</span><br><span class="line">                        unsigned short aValue = [tempObj unsignedShortValue];</span><br><span class="line">                        [invocation setArgument:&amp;aValue atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case YYEncodingTypeInt32:</span><br><span class="line">                    &#123;</span><br><span class="line">                        int32_t aValue = [tempObj intValue];</span><br><span class="line">                        [invocation setArgument:&amp;aValue atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case YYEncodingTypeUInt32:</span><br><span class="line">                    &#123;</span><br><span class="line">                        uint32_t aValue = [tempObj intValue];</span><br><span class="line">                        [invocation setArgument:&amp;aValue atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case YYEncodingTypeInt64:</span><br><span class="line">                    &#123;</span><br><span class="line">                        long long aValue = [tempObj longLongValue];</span><br><span class="line">                        [invocation setArgument:&amp;aValue atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case YYEncodingTypeUInt64:</span><br><span class="line">                    &#123;</span><br><span class="line">                        unsigned long long aValue = [tempObj unsignedLongLongValue];</span><br><span class="line">                        [invocation setArgument:&amp;aValue atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case YYEncodingTypeFloat:</span><br><span class="line">                    &#123;</span><br><span class="line">                        float aValue = [tempObj floatValue];</span><br><span class="line">                        [invocation setArgument:&amp;aValue atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case YYEncodingTypeDouble:</span><br><span class="line">                    &#123;</span><br><span class="line">                        double aValue = [tempObj doubleValue];</span><br><span class="line">                        [invocation setArgument:&amp;aValue atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case YYEncodingTypeLongDouble:</span><br><span class="line">                    &#123;</span><br><span class="line">                        long double aValue = [tempObj doubleValue];</span><br><span class="line">                        [invocation setArgument:&amp;aValue atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case YYEncodingTypeObject:</span><br><span class="line">                    &#123;</span><br><span class="line">                        [invocation setArgument:&amp;tempObj atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    default:</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //调用</span><br><span class="line">            [invocation invoke];</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            [toObj setValue:[self converValueWithObj:obj] forKeyPath:key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这么长一段代码，我都不想看😑，幸好还记得怎么实现的。按照上面我们说的，应该非常简单才对，但是实际上还要处理一些其他情况。举个例子，<code>UIButton</code> 在设置图片、文字颜色等属性的时候需要带上 <code>UIControlState</code>，那就需要传两个参数。<code>Plist</code>可以把这种多参数保存为数组，但是KVC就没办法做到赋值了，这时候就要借助到OC的运行时了。</p><p>我们知道，OC的方法调用，本质都是发送消息，而消息的参数是不确定的，所以我们可以借助底层提供的 <code>NSInvocation</code> 这种通过方法签名发消息的类。如果了解过OC的消息转发机制的同学，应该见过这个类。它其实是一个调用器，设置了方法签名，再设置了参数就可以像普通消息发送了。方法名我们定义成配置的 <code>key</code>，多参数就和OC的方法名一样，用”:”隔开，类似这样：<code>setImage:forState</code>，<code>value</code> 是一个数组。实现用了YYKit的一些方法，只是写起来简单一些，内部就是调用runtime的API，这样就做到了多参数的兼容。</p><p>然而实际使用的时候，其实很麻烦。有一个比较巧妙的方式是通过分类去添加参数。比如 <code>UIButton</code> 的 <code>setImage:forState</code>，我们可以添加这些分类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) UIImage *jh_normalImg;</span><br><span class="line">@property (nonatomic, strong) UIImage *jh_hightlightedImg;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>实现是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)setJh_normalImg:(UIImage *)jh_normalImg &#123;</span><br><span class="line">    [self setImage:jh_normalImg forState:UIControlStateNormal];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIImage *)jh_normalImg &#123;</span><br><span class="line">    return [self imageForState:UIControlStateNormal];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setJh_hightlightedImg:(UIImage *)jh_hightlightedImg &#123;</span><br><span class="line">    [self setImage:jh_hightlightedImg forState:UIControlStateHighlighted];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIImage *)jh_hightlightedImg &#123;</span><br><span class="line">    return [self imageForState:UIControlStateHighlighted];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过分类指定其它的参数就可以像单个参数那样使用了。</p><p>至于自动调用，其实很简单。我们给 <code>NSObject</code> 添加一个分类，实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@implementation NSObject (JHThemeManager)</span><br><span class="line"></span><br><span class="line">- (void)jh_updateTheme &#123;</span><br><span class="line">    [self jh_updateThemeByKey:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)jh_updateThemeByKey:(NSString *)key &#123;</span><br><span class="line">    [self jh_updateThemeByKey:key block:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)jh_updateThemeByKey:(NSString *)key</span><br><span class="line">                      block:(JHThemeCustomAction)block &#123;</span><br><span class="line">    [self jh_updateThemeByKey:key theme:nil block:block];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)jh_updateThemeByKey:(NSString *)key</span><br><span class="line">                      theme:(NSString *)theme</span><br><span class="line">                      block:(JHThemeCustomAction)block &#123;</span><br><span class="line">    [[JHThemeManager shareThemeManager] updateObjStyleWithCurrentTheme:self themeKey:key themeName:theme block:block];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>其实也只不过是对 <code>[[JHThemeManager shareThemeManager] updateObjStyleWithCurrentTheme:self themeKey:key themeName:theme block:block];</code> 的封装，这个key是配置里的 <code>key</code>，一般定义成类名。<code>theme</code> 就是主题的名字，传 <code>nil</code>的话就获取当前主题。然后创建在你的控制器基类、各种View的基类中合适的时机调用 <code>- (void)jh_updateTheme</code> 就会自动在生成时进行主题设置。</p><p>配置文件是这样的：<br><img src="/sunsx9316/2018/08/26/APP切换主题的一些思考/img.jpg" alt="img"></p><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>实际使用中，这个轮子并不太方便。一是因为代码都在 <code>Plist</code> 里，不能非常直观的看到样式的设置过程。而且要求key与类中的属性，代码一旦有修改，<code>Plist</code>也需要做修改。最重要的一点是 <code>Value</code> 字符串的书写不能出错，但这是不太容易的，因为人就是个Bug。</p><p>比较好的解决方式就是写个GUI工具，能浏览和生成配置，而不是通过手工添加。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;APP内切换主题是比较常见的需要，蛮早就思考过这个问题。网上也有很多的解决方案，不过本质上其实都类似，无非是两种情况。&lt;/p&gt;
&lt;ul&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>UITableView+FDTemplateLayoutCell计算行高一些缺陷的解决方法</title>
    <link href="https://github.com/sunsx9316/2018/08/26/UITableView-FDTemplateLayoutCell%E8%AE%A1%E7%AE%97%E8%A1%8C%E9%AB%98%E4%B8%80%E4%BA%9B%E7%BC%BA%E9%99%B7%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://github.com/sunsx9316/2018/08/26/UITableView-FDTemplateLayoutCell计算行高一些缺陷的解决方法/</id>
    <published>2018-08-25T18:27:38.000Z</published>
    <updated>2018-12-15T14:05:57.998Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>UITableView动态行高一直是iOS的一个经典问题，在没有AutoLayout的时代，只能自己计算<strong>frame</strong>，然后返回给代理，非常痛苦。到了AutoLayout的时代，布局就变得简单多了，甚至于通过系统提供的API都能自动计算出行高。</p><p><a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell">UITableView+FDTemplateLayoutCell</a>就是<a href="https://github.com/sunnyxx">sunnyxx</a>大大的一个自动计算行高的框架。只要布局正确，通过它可以自动计算并缓存行高，非常方便。不过在使用上发现一些问题，也尝试去解决了。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>需求是这样的，一个类似微博的页面，像这样：</p><p><img src="/sunsx9316/2018/08/26/UITableView-FDTemplateLayoutCell计算行高一些缺陷的解决方法/1320218-1fc431e9a8a7a4f9.jpg" alt="img1"></p><p>这应该是比较经典的布局，内容和图片都是不确定的，行高要根据实际数据计算。九宫格实现方式有很多，我这里是通过UICollectionView去实现的。这样的一个好处就是UICollectionView的高度可以通过它的<strong>collectionViewLayout</strong>对象获取，啥都不用算。不过会有一个问题，UICollectionView继承自UIScrollView，它的高度没法按照内容来全显示。所以即使布局正确，通过AutoLayout来计算行高也是不包括UICollectionView的，这个问题同样反映在一些UIView控件上。</p><p>这就十分蛋疼了，难道还要回到手算frame的时代？当然不是，是我还写啥博客。</p><p>我说下解决的几个方法。</p><p><strong>方法一（不推荐）</strong>：手动设置collectionView的高度，可以通过代码或者xib来设置，我这里是xib。</p><p><img src="/sunsx9316/2018/08/26/UITableView-FDTemplateLayoutCell计算行高一些缺陷的解决方法/1320218-decdeddd6bfaee61.png" alt="img2"></p><p>像这样手动指定collectionView的高度，然后赋值数据源的时候更新collectionView高度约束就可以了，让它的高度等于它的<strong>contentSize.height</strong>，这样就能全部显示了，其它UIView控件也能这么解决。但是这样在计算行高的时候会抛出非常多异常，都是约束的问题。我不是很清楚这是什么原因，按理说计算再后，赋值在前，应该不会这样。而且显示会出一些问题，计算的行高会不正确，有些许误差。</p><p><strong>方法二（推荐）</strong>：既然不能通过这种方式，那就绕个弯吧。去掉高度约束，计算出来的高就不包含collectionView的高。然后再手动加上collectionView的高返回给代理不就行了。不过看下<a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell">UITableView+FDTemplateLayoutCell</a>的拓展方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier</span><br><span class="line">configuration:(void (^)(id cell))configuration;</span><br></pre></td></tr></table></figure></p><p>只有一个设置cell数据源的block，正常情况下我们只需要把cell换成我们自己的类，然后赋值模型就行，缓存之类的框架会自动处理好。虽然我们可以获取到缓存高度之后再加上collectionView的高，但是这样还叫啥缓存，缓存就是不需要计算，直接取到就能用，那怎么办呢？<br>虽然可以通过<strong>Method Swizzling</strong>黑魔法交换方法实现，但是这并不是最优方法，往往是一些莫名其妙的bug的源泉，作为开发者应该尽量避免这种方式。所以最后我选择了通过分类的方式。思路是在框架计算完高度之后通过block返回，我们自行处理行高，加加减减，然后返回高度让框架缓存。<br>具体代码：<br>我们参考下框架这个方法的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier</span><br><span class="line">cacheByIndexPath:(NSIndexPath *)indexPath</span><br><span class="line">configuration:(void (^)(id cell))configuration &#123;</span><br><span class="line">if (!identifier || !indexPath) &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//命中缓存</span><br><span class="line">if ([self.fd_indexPathHeightCache existsHeightAtIndexPath:indexPath]) &#123;</span><br><span class="line">[self fd_debugLog:[NSString stringWithFormat:@&quot;hit cache by index path[%@:%@] - %@&quot;, @(indexPath.section), @(indexPath.row), @([self.fd_indexPathHeightCache heightForIndexPath:indexPath])]];</span><br><span class="line">return [self.fd_indexPathHeightCache heightForIndexPath:indexPath];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//计算行高</span><br><span class="line">CGFloat height = [self fd_heightForCellWithIdentifier:identifier configuration:configuration];</span><br><span class="line">[self.fd_indexPathHeightCache cacheHeight:height byIndexPath:indexPath];</span><br><span class="line">[self fd_debugLog:[NSString stringWithFormat: @&quot;cached by index path[%@:%@] - %@&quot;, @(indexPath.section), @(indexPath.row), @(height)]];</span><br><span class="line"></span><br><span class="line">return height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它先从缓存中寻找行高，命中之后直接返回。否则计算行高，存入缓存，然后返回。所以很简单，我们可以直接复制它的代码。写一个带编辑行高功能的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">typedef CGFloat(^editCellHeightAction)(id cell, CGFloat cellHeight);</span><br><span class="line"></span><br><span class="line">- (CGFloat)jh_heightForCellWithIdentifier:(NSString *)identifier</span><br><span class="line">cacheByIndexPath:(NSIndexPath *)indexPath</span><br><span class="line">configuration:(void (^)(id cell))configuration</span><br><span class="line">editAction:(editCellHeightAction)editAction &#123;</span><br><span class="line">if (!identifier || !indexPath) &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">// Hit cache</span><br><span class="line">if ([self.fd_indexPathHeightCache existsHeightAtIndexPath:indexPath]) &#123;</span><br><span class="line">[self fd_debugLog:[NSString stringWithFormat:@&quot;hit cache by index path[%@:%@] - %@&quot;, @(indexPath.section), @(indexPath.row), @([self.fd_indexPathHeightCache heightForIndexPath:indexPath])]];</span><br><span class="line">return [self.fd_indexPathHeightCache heightForIndexPath:indexPath];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CGFloat height = 0;</span><br><span class="line">//获取缓存中的cell</span><br><span class="line">UITableViewCell *templateLayoutCell = [self fd_templateCellForReuseIdentifier:identifier];</span><br><span class="line">//这里插入编辑行高的代码</span><br><span class="line">if (editAction) &#123;</span><br><span class="line">height = editAction(templateLayoutCell, [self fd_heightForCellWithIdentifier:identifier configuration:configuration]);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">height = [self fd_heightForCellWithIdentifier:identifier configuration:configuration];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[self.fd_indexPathHeightCache cacheHeight:height byIndexPath:indexPath];</span><br><span class="line">[self fd_debugLog:[NSString stringWithFormat: @&quot;cached by index path[%@:%@] - %@&quot;, @(indexPath.section), @(indexPath.row), @(height)]];</span><br><span class="line">return height;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用起来像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (CGFloat)tableView:(UITableView *)tableView</span><br><span class="line">heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">return [tableView jh_heightForCellWithIdentifier:@&quot;MineCell&quot; cacheByIndexPath:indexPath configuration:^(HeSquareCell *cell) &#123;</span><br><span class="line">//正常赋值数据源</span><br><span class="line">cell.model = self.model;</span><br><span class="line">&#125; editAction:^CGFloat(MineCell *cell, CGFloat cellHeight) &#123;</span><br><span class="line">//cellHeight是上面的block计算后回调过来的 所以直接加上额外的高度即可</span><br><span class="line">//因为缓存的关系这里只会走一次 所以可以放心写</span><br><span class="line">return cellHeight + [cell collectionViewHeightWithModel:self.model];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样高度就能正常显示了，而且也不会抛异常，还能享受框架带来的便利。<br><a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell">UITableView+FDTemplateLayoutCell</a>的接口设计很易于拓展，所以写起来很简单。还有个问题，我发现在使用这个框架的时候，如果<code>_tableView.tableFooterView = [[UIView alloc] init];</code>这句话写在注册cell之前，程序会crash，不造为啥。如果各位有更好的解决思路或者文中有错误的地方欢迎给我留言。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;UITableView动态行高一直是iOS的一个经典问题，在没有AutoLayout的时代，只能自己计算&lt;strong&gt;frame&lt;/str
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="https://github.com/sunsx9316/2018/08/26/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>https://github.com/sunsx9316/2018/08/26/第一篇博客/</id>
    <published>2018-08-25T16:55:41.870Z</published>
    <updated>2018-08-25T16:55:41.870Z</updated>
    
    <content type="html"><![CDATA[<p>最近决定要开始写博客了，打算先把简书的搬过来。这一年接触了很多东西，觉得需要记录下来，自己搭博客还蛮有意思的:)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近决定要开始写博客了，打算先把简书的搬过来。这一年接触了很多东西，觉得需要记录下来，自己搭博客还蛮有意思的:)&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
