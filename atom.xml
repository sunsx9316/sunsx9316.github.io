<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jimhuang的博客</title>
  
  <subtitle>一个iOS/Mac开发</subtitle>
  <link href="https://github.com/sunsx9316/atom.xml" rel="self"/>
  
  <link href="https://github.com/sunsx9316/"/>
  <updated>2020-02-14T08:00:17.954Z</updated>
  <id>https://github.com/sunsx9316/</id>
  
  <author>
    <name>jimhuang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mac安装虚拟机提示应用副本已损坏解决办法</title>
    <link href="https://github.com/sunsx9316/2020/02/14/Mac%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8F%90%E7%A4%BA%E5%BA%94%E7%94%A8%E5%89%AF%E6%9C%AC%E5%B7%B2%E6%8D%9F%E5%9D%8F%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>https://github.com/sunsx9316/2020/02/14/Mac%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8F%90%E7%A4%BA%E5%BA%94%E7%94%A8%E5%89%AF%E6%9C%AC%E5%B7%B2%E6%8D%9F%E5%9D%8F%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</id>
    <published>2020-02-14T07:58:37.000Z</published>
    <updated>2020-02-14T08:00:17.954Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Mac 开发不像 iOS，没有完整的调试环境模拟真机，所以在做版本兼容测试，或者查旧版系统 Bug 时只能借助虚拟机。之前发现<strong>Mac OS 10.12</strong>虚拟机安装出现了问题，现在把解决的方法分享出来。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h4 id="碰到的问题"><a href="#碰到的问题" class="headerlink" title="碰到的问题"></a>碰到的问题</h4><p>安装的时候，碰到安装错误，提示<strong>应用副本已损坏</strong>，或者<strong>安装器有效负载签名检查失败</strong>。查了下发现是系统时间的问题，所以下面给出解决办法。</p><p><img src="/sunsx9316/Mac%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8F%90%E7%A4%BA%E5%BA%94%E7%94%A8%E5%89%AF%E6%9C%AC%E5%B7%B2%E6%8D%9F%E5%9D%8F%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/1.png"></p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><ol><li><p>直接调整系统的时间。</p><p>  手动调整系统年份为<strong>2017年</strong>即可，年月日时分秒无需调整。虚拟机也无须断网，测试可以正常安装。</p><blockquote><p>优点：操作简单。<br>缺点：修改了系统时间可能会有一些问题，比如影响浏览器证书验证，邮箱接收等，需要在安装完改回正确的时间。</p></blockquote></li><li><p>只修改虚拟机的时间。</p><p> 步骤：</p><ol><li><p>虚拟机需要断网。</p></li><li><p>虚拟机打开 实用工具 &gt; 终端。</p></li><li><p>输入 date + 时间（年份需要替换成2017）。例如当前是2020年2月14日15:19:20，那就应该输入 <strong>date 021415192017.20</strong>，和系统时分秒误差要在1分钟内。</p><blockquote><p>02是月，14是日，15是时，19是分，2017是年，20是秒。</p></blockquote></li><li><p>如果仍然有问题，年份可以试试向前改，比如2015。</p></li></ol><blockquote><p>优点：不影响系统运行，该干嘛干嘛。<br>缺点：操作相对复杂。</p></blockquote></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;Mac 开发不像 iOS，没有完整的调试环境模拟真机，所以在做版本兼容测试，或者查旧版系统 Bug 时只能借助虚拟机。之前发现&lt;strong</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>用更优雅的方式使用KVO</title>
    <link href="https://github.com/sunsx9316/2019/08/17/%E7%94%A8%E6%9B%B4%E4%BC%98%E9%9B%85%E7%9A%84%E6%96%B9%E5%BC%8F%E4%BD%BF%E7%94%A8KVO/"/>
    <id>https://github.com/sunsx9316/2019/08/17/%E7%94%A8%E6%9B%B4%E4%BC%98%E9%9B%85%E7%9A%84%E6%96%B9%E5%BC%8F%E4%BD%BF%E7%94%A8KVO/</id>
    <published>2019-08-17T02:55:37.000Z</published>
    <updated>2019-08-17T03:06:31.955Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在做项目的改造工作，发现了项目中用到了不少KVO，而且是通过字符串硬编码的方式书写，正所谓复制一时爽，重构火葬场，底层重构属性的时候这种字符串是不会给错误或者警告提示的，造成了排查的困难。以前个人使用过一个叫<code>libextobjc</code>的拓展库，里面有一些对keypath的封装，可以在编译期生成并且检查keypath，非常方便。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>这部分KVO的拓展叫<code>EXTKeyPathCoding</code>，官方注释说支持两种写法。</p><ol><li><p><code>NSString *UTF8StringPath = @keypath(str.lowercaseString.UTF8String); // =&gt; @&quot;lowercaseString.UTF8String&quot;</code></p></li><li><p><code>NSString *lowercaseStringPath = @keypath(NSString.new, lowercaseString); // =&gt; @&quot;lowercaseString&quot;</code></p></li></ol><p>非常简洁明了，第一种比较直观，连续的点语法会截掉第一个<code>&quot;.&quot;</code>之前，保留之后的字符串。第二种只保留<code>&quot;,&quot;</code>后的字符串。值得一提的是对于类属性，也支持这种语法。比如这样：<br><code>NSString *versionPath = @keypath(NSObject, version);// =&gt; @&quot;version&quot;</code></p><p><strong>对于只是想了解用法的同学，下面的原理可以直接跳过，看最后的注意事项即可。</strong></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>近来有同事问起原理，于是深入研究了下，感叹作者对宏定义用法的炉火纯青，现在把过程分享出来。</p><p>先看源码，对于<code>@keypath</code>，主要的宏定义是这样写的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#define keypath(...) \</span><br><span class="line">    _Pragma(&quot;clang diagnostic push&quot;) \</span><br><span class="line">    _Pragma(&quot;clang diagnostic ignored \&quot;-Warc-repeated-use-of-weak\&quot;&quot;) \</span><br><span class="line">    (NO).boolValue ? ((NSString * _Nonnull)nil) : ((NSString * _Nonnull)@(cStringKeypath(__VA_ARGS__))) \</span><br><span class="line">    _Pragma(&quot;clang diagnostic pop&quot;) \</span><br><span class="line"></span><br><span class="line">#define cStringKeypath(...) \</span><br><span class="line">    metamacro_if_eq(1, metamacro_argcount(__VA_ARGS__))(keypath1(__VA_ARGS__))(keypath2(__VA_ARGS__))</span><br><span class="line"></span><br><span class="line">#define keypath1(PATH) \</span><br><span class="line">    (((void)(NO &amp;&amp; ((void)PATH, NO)), \</span><br><span class="line">    (&#123; char *__extobjckeypath__ = strchr(# PATH, &#x27;.&#x27;); NSCAssert(__extobjckeypath__, @&quot;Provided key path is invalid.&quot;); __extobjckeypath__ + 1; &#125;)))</span><br><span class="line"></span><br><span class="line">#define keypath2(OBJ, PATH) \</span><br><span class="line">    (((void)(NO &amp;&amp; ((void)OBJ.PATH, NO)), # PATH))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看到的时候我的表情是黑人问号，幸好xcode有牛x闪闪的预处理功能，点击这里能看到：<br><img src="/sunsx9316/%E7%94%A8%E6%9B%B4%E4%BC%98%E9%9B%85%E7%9A%84%E6%96%B9%E5%BC%8F%E4%BD%BF%E7%94%A8KVO/1.png" alt="图片"></p><p>对于<code>@keypath(self.view)</code>展开后去掉断言等无关代码，核心代码变成了这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@(__objc_no).boolValue ? ((NSString * _Nonnull)((void *)0)) : </span><br><span class="line"></span><br><span class="line">((NSString * _Nonnull)@((((void)(__objc_no &amp;&amp; ((void)self.view, __objc_no)), </span><br><span class="line"></span><br><span class="line">(&#123; char *__extobjckeypath__ = strchr(&quot;self.view&quot;, &#x27;.&#x27;);  __extobjckeypath__ + 1; &#125;))) ));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们看到，这个宏定义就是一个三目运算符，接下来我们一步一步分析做了什么。</p><p>看第一行<code>@(__objc_no).boolValue ? ((NSString * _Nonnull)((void *)0))</code>，<code>__objc_no </code>就是<code>NO</code>，这里通过<code>@(NO)</code>将基本类型<code>NO</code>封装成了NSNumber。</p><p>而<code>((NSString * _Nonnull)((void *)0))</code>其实就是<code>((NSString * _Nonnull)nil)</code>。</p><p>所以这表达式简单写就是 <code>@(NO).boolValue ? nil : 巴拉巴拉</code>。或许你会疑惑这个三木运算符的意义何在，经过测试，移除掉没啥影响，我猜就是为了前面可以加一个酷炫的<code>@</code>符号吧。<code>RAC</code>里有<code>@weakify</code>这种写法也是要加<code>@</code>，其实也没什么用，就是为了酷炫，哈哈哈。</p><p>接下来我们看看第二行<code>((NSString * _Nonnull)@((((void)(__objc_no &amp;&amp; ((void)self.view, __objc_no))</code>，这句最大的意义其实就是提供了<code>self.view</code>让编译器能检查拼写。其实这里就是上面的<code>#define keypath1 (void)(NO &amp;&amp; ((void)PATH, NO))</code>展开的内容。这里用到了C语言里一些不太常用的写法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int c = (a, b)</span><br></pre></td></tr></table></figure><p>c最后的取值会是b。但是这样写编译器会报警告，简单的做法就是改成这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int c = ((void)a, b)</span><br></pre></td></tr></table></figure><p>所以这里写void的原因你也理解了吧。</p><p>然后看最后一句：<code>(&#123; char *__extobjckeypath__ = strchr(&quot;self.view&quot;, &#39;.&#39;);  __extobjckeypath__ + 1; &#125;)</code>。</p><p>这一句是由<code>keypath1</code>的后半部分展开而来。</p><p><code>strchr</code>是c语言中寻找一个字符在另一个字符串中第一次出现的位置的函数，找到会返回位置的指针，没找到返回<code>NULL</code>。具体到这里，就是找到<code>&#39;.&#39;</code>在<code>&quot;self.view&quot;</code>中第一次出现的位置。这里+1相当于截断了<code>&#39;.&#39;</code>之前包括<code>&#39;.&#39;</code>的内容，所以能理解为什么它能找到对应的<code>keypath</code>了吧。<code>&#123;()&#125;</code>也是一个语法糖，会把最后一行做为表达式的返回值。好处就是在大括号中有自己的局部变量作用域，在临时变量很多，难以管理的时候这种写法可以比较优雅的解决问题。常见的写法像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSArray *arr = (&#123;</span><br><span class="line">        NSMutableArray *mArr = [NSMutableArray array];</span><br><span class="line">        [mArr addObject:@(123)];</span><br><span class="line">        mArr;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后arr的取值会是mArr，不需要写return。</p><p>最后我们看到，返回值被<code>@()</code>包住，这是什么语法？我们知道<code>@(123)</code>这个语法糖会生成NSNumber，而比较少见的<code>@(&quot;123&quot;)</code>则会生成<code>NSString</code>。这里的<code>char *__extobjckeypath__</code>就是一个c的字符串，所以你理解为什么最后能生成了一个<code>NSString</code>了吧。</p><p>讲到这里我们梳理完了第一种<code>keypath</code>的写法，第二种写法原理大致相同，在宏定义中 <code># 变量名</code>的写法会直接转换成c字符串，这就是第二种写法会把<code>,</code>之后的内容转换成字符串的基础。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们可以看到作者对宏定义的运用到了非常高的水平，如果感兴趣，还可以阅读开源库里其它模块的代码，很值得研究。</p><p>说一下注意点，有同事在写<code>keypath</code>的时候写过类似这样的代码：</p><p><code>@keypath(XXManager.shareManager.abc)</code>，编译没有任何问题，跑起来却crash了，报错是<code>xxx was sent to an object that is not KVC-compliant for the &quot;shareManager&quot; property.</code>为什么？</p><p>其实不是这个库的锅，因为<code>shareManager</code>是个类属性，它的<code>get</code>方法本质其实是个类方法，而只有实例属性才支持KVO，所以一定要小心。改法也很简单，使用第二种写法就行<code>@keypath(FTManager.shareManager, abc)</code></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.sunnyxx.com/2014/03/06/rac_1_macros/">Reactive Cocoa Tutorial [1] = 神奇的Macros</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近在做项目的改造工作，发现了项目中用到了不少KVO，而且是通过字符串硬编码的方式书写，正所谓复制一时爽，重构火葬场，底层重构属性的时候这种</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Flutter学习笔记(一)</title>
    <link href="https://github.com/sunsx9316/2019/03/31/Flutter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/"/>
    <id>https://github.com/sunsx9316/2019/03/31/Flutter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/</id>
    <published>2019-03-31T13:27:53.000Z</published>
    <updated>2019-03-31T15:42:01.897Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近来大前端时代成为了一个很火热的词，各种跨平台的前端框架也不断涌现。不过我个人其实并不太看好这种框架，个人感觉一套代码全平台通用的想法是很好，但是平台是存在差异性的，特别是每个平台还有很多特有的属性，所以要做好终归只能原生。不过作为程序员，学习和了解新技术总没什么错，特别是要清楚本质，所以这里记录下自己学习<a href="https://flutter.dev/">flutter</a>的过程。</p><h2 id="Flutter是啥"><a href="#Flutter是啥" class="headerlink" title="Flutter是啥"></a>Flutter是啥</h2><p><a href="https://flutter.dev/">flutter</a>是Google开发，用于跨平台开发(目前支持Android和iOS)的一个框架。相比于H5+原生混合开发、React Native或Weex，flutter诞生的比较晚，从第一个beta版本到现在也不过一年。但是可以看到在Google强大的号召力下，开源社区非常火热。flutter和React Native、Weex这些框架最大的区别，应该在于flutter采用自绘引擎，既不使用原生控件，也不使用webView。这样的好处是能做到多端UI表现的一致，也就是真正意义的跨平台了。不过UI其实只是一部分，将来希望能做到更多API的统一。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>万丈高楼平地起，这一章主要说安装。</p><p>flutter的社区很火热，在国内有专门的<a href="https://flutterchina.club/flutter-for-ios/#%E6%88%91%E6%80%8E%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8E%9F%E7%94%9F%E9%9B%86%E6%88%90%E5%B1%82">中文网</a>，仔细阅读就能解决国内开发基本都会碰到的问题。所以上面写了的我就简单略过，只讲自己碰到的坑。</p><p>因为安卓是亲儿子，flutter对于Android的支持完善的多，而苦逼的iOS搭建完整的开发环境还是相对麻烦。本人使用VSCode+插件的方式开发，前面的配置环境变量，安装插件什么的一切顺利，主要问题出现在了安装iOS设备工具这里。</p><p>本人使用的是稳定版本，目前是<a href="https://storage.googleapis.com/flutter_infra/releases/stable/macos/flutter_macos_v1.2.1-stable.zip">v1.2.1</a>。<br>官方的说明很简单，通过<a href="https://brew.sh/">Homebrew</a>一键安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">brew update</span><br><span class="line">brew install --HEAD libimobiledevice</span><br><span class="line">brew install ideviceinstaller ios-deploy cocoapods</span><br><span class="line">pod setup</span><br></pre></td></tr></table></figure><p>问题出在了<code>brew install --HEAD libimobiledevice</code>这个东西上。<br>因为Homebrew会自动检测包依赖，然后他帮我装了<code>python</code>，这就是噩梦的开始。</p><p>默认Homebrew安装的是python3，而Mac OS自带的是python2。所以就会出现两个版本。不过不用担心Homebrew会帮你处理好。由于本人python只是略懂皮毛，所以以下的处理方式可能在专业人士看来比较不妥，有更好的方式欢迎给我提issue。</p><p>安装出现了这个错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">checking consistency of all components of python development environment... no</span><br><span class="line">configure: error:</span><br><span class="line">  Could not link test program to Python. Maybe the main Python library has been</span><br><span class="line">  installed in some non-standard library path. If so, pass it to configure,</span><br><span class="line">  via the LDFLAGS environment variable.</span><br><span class="line">  Example: ./configure LDFLAGS=&quot;-L/usr/non-standard-path/python/lib&quot;</span><br><span class="line">  ============================================================================</span><br><span class="line">   ERROR!</span><br><span class="line">   You probably have to install the development version of the Python package</span><br><span class="line">   for your distribution.  The exact name of this package varies among them.</span><br><span class="line">  ============================================================================</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>emmm …… 我当时就是这个表情<img src="/sunsx9316/2019/03/31/Flutter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/6F4AFA5C079CB313AE50613696E1D366.jpg" alt="img"> </p><p>查了下发现<code>libimobiledevice</code>这是一个用来和iPhone通信的库，如果不管其实也可以，但是就没法体验flutter的热重载了。所以我们还是得上。错误大致上是说不能链接到python。于是看了看flutter在github上的issue，发现还真有人碰到。大致说这是Homebrew的问题，但是解决方法没说明白。再google，有一些和flutter无关的搜索结果，给出的解决方案大多是安装python-dev，这玩意是Linux上的，mac没有，那就只能自己琢磨了。</p><p>一开始猜测可能是多版本python的问题，导致脚本找不到python真正的目录，google之后发现可以通过配置$PATH的方式将python路径加入到环境变量中。命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$&#123;PATH&#125;:/Library/Frameworks/Python.framework/Versions/3.6/bin</span><br></pre></td></tr></table></figure><p>满怀希望的再装一次，发现还是报这个错。于是看看他的log，有这么一段话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">via the LDFLAGS environment variable.</span><br><span class="line">  Example: ./configure LDFLAGS=&quot;-L/usr/non-standard-path/python/lib&quot;</span><br></pre></td></tr></table></figure><p>大概是让我执行<code>./configure</code>这个文件的时候指定<code>LDFLAGS</code>这个环境变量为外部的python路径。log里有报错的脚本路径，我的在这里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/Library/Caches/Homebrew/libimobiledevice:</span><br></pre></td></tr></table></figure><p>cd到这个目录，发现是Homebrew缓存libimobiledevice安装脚本的目录。里面有Log提到的<code>configure</code>文件。熟悉Linux的同学应该知道这玩意，这个是手动编译一些库的时候常见的配置脚本。其实这里就是要我们自己手动安装了。好，那我们自己手动加上Python的外部路径，Homebrew的python安装在这里:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/Cellar/python/3.7.3/Frameworks/Python.framework/Versions/3.7/lib</span><br></pre></td></tr></table></figure><p>在当前目录执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure LDFLAGS=&quot;-L/usr/local/Cellar/python/3.7.3/Frameworks/Python.framework/Versions/3.7/lib&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>满心欢喜，发现并没有什么卵用。以为是书写方式或者路径不对，做了很多尝试，依然无果。<img src="/sunsx9316/2019/03/31/Flutter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/0DAFA227E38C20F61AB1A971BCF784D6.jpg" alt="img1"> 只能看看脚本写的是啥了。</p><p>编辑器打开<code>./configure</code>，发现是个shell脚本。搜了下报错信息，发现了这么些代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if ac_fn_c_try_link &quot;$LINENO&quot;; then :</span><br><span class="line">  pythonexists=yes</span><br><span class="line">else</span><br><span class="line">  pythonexists=no</span><br><span class="line">fi</span><br><span class="line">rm -f core conftest.err conftest.$ac_objext \</span><br><span class="line">    conftest$ac_exeext conftest.$ac_ext</span><br><span class="line"></span><br><span class="line">&#123; $as_echo &quot;$as_me:$&#123;as_lineno-$LINENO&#125;: result: $pythonexists&quot; &gt;&amp;5</span><br><span class="line">$as_echo &quot;$pythonexists&quot; &gt;&amp;6; &#125;</span><br></pre></td></tr></table></figure><p>以我半桶水的shell基础大致就是尝试链接python，底下的代码会通过<code>pythonexists</code>这个标识判断是否链接成功。我们的python其实是能找到的，但是上面的代码不知道为啥报错了，于是我试着在<code>rm -f core conftest.err conftest.$ac_objext </code>的上一行直接粗暴的把<code>pythonexists</code>改为yes。像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if ac_fn_c_try_link &quot;$LINENO&quot;; then :</span><br><span class="line">  pythonexists=yes</span><br><span class="line">else</span><br><span class="line">  pythonexists=no</span><br><span class="line">fi</span><br><span class="line">pythonexists=yes # 加入这行</span><br><span class="line">rm -f core conftest.err conftest.$ac_objext \</span><br></pre></td></tr></table></figure><p>保存运行，发现真的没报这个错了。但是又迎来了另一个错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">checking for openssl &gt;= 0.9.8... no</span><br><span class="line">configure: error: OpenSSL support explicitly requested but OpenSSL could not be found</span><br></pre></td></tr></table></figure><p>WTF？OpenSSL我明明装了，这又搞毛线。google一下发现是mac自带的版本比较旧，最简单的方法是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./autogen.sh --disable-openssl</span><br></pre></td></tr></table></figure><p>然后居然没报错，Every Thing is OK. 接下来 <code>make install</code>就好了。</p><p>然后没有两秒又报错了？？？<img src="/sunsx9316/2019/03/31/Flutter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/1e976bbd4b19f323633b83bfea11016f7b4290fa.gif" alt="img2"></p><p>好吧，看看报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.14.sdk/usr/include/inttypes.h:250:8: error:</span><br><span class="line">      unknown type name &#x27;intmax_t&#x27;</span><br></pre></td></tr></table></figure><p>说的是系统的SDK里没有定义<code>intmax_t</code>这东西，猜测是编译版本的问题。goolge发现人家直接简单粗暴给你加上定义。我们打开Xcode看下<code>intmax_t</code>的定义。</p><p>长这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#ifndef _INTMAX_T</span><br><span class="line">#define _INTMAX_T</span><br><span class="line">#ifdef __INTMAX_TYPE__</span><br><span class="line">typedef __INTMAX_TYPE__ intmax_t;</span><br><span class="line">#else</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">typedef long int intmax_t;</span><br><span class="line">#else</span><br><span class="line">typedef long long int intmax_t;</span><br><span class="line">#endif /* __LP64__ */</span><br><span class="line">#endif /* __INTMAX_TYPE__ */</span><br><span class="line">#endif /* _INTMAX_T */</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其实就是个INTMAX的别名。然后我们把他粘贴到上面报错的头文件中。(<code>uintmax_t</code>也是一样)</p><p>之后出现的错误都类似处理，补全定义。</p><p>然后，编译通过了~ <img src="/sunsx9316/2019/03/31/Flutter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/66179FCE3CB80A6F43E547D593B29907.gif" alt="img3"></p><p>当然，随便改系统定义的头文件不知道会有什么后果，所以在安装完成之后我就把他复原了。接下来试试flutter的热重载，正常，安装到此结束。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>其实还尝试过Android Studio，结果新建flutter工程直接卡死，心累不想找解决方案了，以后flutter能省点心就好了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;近来大前端时代成为了一个很火热的词，各种跨平台的前端框架也不断涌现。不过我个人其实并不太看好这种框架，个人感觉一套代码全平台通用的想法是很</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>对于订阅和反订阅的一些思考</title>
    <link href="https://github.com/sunsx9316/2018/12/15/%E5%AF%B9%E4%BA%8E%E8%AE%A2%E9%98%85%E5%92%8C%E5%8F%8D%E8%AE%A2%E9%98%85%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <id>https://github.com/sunsx9316/2018/12/15/%E5%AF%B9%E4%BA%8E%E8%AE%A2%E9%98%85%E5%92%8C%E5%8F%8D%E8%AE%A2%E9%98%85%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</id>
    <published>2018-12-15T07:50:44.000Z</published>
    <updated>2019-08-07T14:41:56.657Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为项目的一些历史原因，最近在进行重构，碰到了一些比较核心的订阅部分，写出来记录一下。</p><p>订阅这个概念我是首先在RAC里见到。在响应式编程里一切都是数据流，RAC在实现上创建了信号和订阅的概念，你可以监听信号的变化，iOS底层是通过KVO和运行时实现的。KVO大家应该比较熟悉，网上说它原理的文章太多了，大致就是通过运行时动态创建子类，hook属性的set方法，在值改变的时候回调，不过我们需要自己手动移除监听，否则会存在内存问题，这个设计饱受诟病。从Swift 4.0开始，KVO有了一种新的写法。API是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func observe&lt;Value&gt;(_ keyPath: KeyPath&lt;Observer, Value&gt;,</span><br><span class="line">  options: NSKeyValueObservingOptions = default,</span><br><span class="line">  changeHandler: @escaping (Observer, NSKeyValueObservedChange&lt;Value&gt;) -&gt; Void) -&gt; NSKeyValueObservation</span><br></pre></td></tr></table></figure><p>然后我们就可以这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class TestObj: NSObject &#123;</span><br><span class="line">    @objc dynamic var str = &quot;&quot;</span><br><span class="line"></span><br><span class="line">    var observer: NSKeyValueObservation?</span><br><span class="line"></span><br><span class="line">    func testKVO() &#123;</span><br><span class="line">        self.observer = self.observe(\.str, options: .new) &#123; (obj, values) in</span><br><span class="line">            print(values)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是必须创建一个强引用持有返回的对象，否则监听事件就无效了。这个对象的类型是<code>NSKeyValueObservation</code>，结构很简单，定义是这样的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class NSKeyValueObservation : NSObject &#123;</span><br><span class="line"></span><br><span class="line">    ///invalidate() will be called automatically when an NSKeyValueObservation is deinited</span><br><span class="line">    public func invalidate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释说这个对象在释放的时候会自动解除引用，也就是说不需要我们自己手动移除KVO监听了，监听事件和对象的生命周期绑定。RAC的里的<code>RACKVOTrampoline</code>就是这种实现的一个例子。</p><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>先说说业务场景。App在某些页面需要给服务器发送指令，请求返回相应的数据。项目里因为对数据实时性要求比较高，而且为了统一前端和移动端，使用了<code>WebSocket</code>协议。指令存在很多种类型，有针对单个Tab的，或者详情页中针对单个币种的，他们之间互不影响。但是和订阅一样，有订阅就有反订阅，所以在不需要的时候需要向服务器发送取消的指令。所以我希望这里的指令能像上面说的订阅模型一样，在对象销毁的时候自动发送取消指令。RAC有一套比较完整的订阅模式，但是依赖比较严重，项目中希望慢慢移除掉它，所以实现了一个更贴近业务轻量的框架。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>其实指令大致就分为两类，一种是tab指令，一种是单个币种的指令。单就这两个就没什么好说的了，无非就是页面出现的时候创建指令对象，发指令给服务器，页面销毁也就发送取消的指令给服务器，中断数据传输。<br>唯一一个复杂的点在单个币种指令的集合。因为有一种业务场景是这样的，本地允许用户添加自选，不上传服务器。那么服务器没办法知道用户的自选列表里有什么，传什么数据就需要App自己指定。当时为了赶需求，这种方式就直接使用了单个指令，有多少个自选币种，就创建多少个指令对象。虽然简单粗暴，但是在取消的时候就有一些麻烦了。后来重构，发现确实也只有这种方式可行，这和业务场景有关。比如我从本地自选A页面跳转到某个需要发送单个指令的页面B，这时候订阅对象应该是复用的，因为从B页面回到A的时候，单个指令也并不应该销毁，因为A页面依然持有它。当时为了这个问题头疼了很久，后来恍然大悟，这不就是和MRC原理差不多嘛。</p><p>明白了之后就很简单了。</p><ol><li>首先在自选列表A页面需要发送指令的时候由一个全局的管理器创建一个指令对象给A页面持有，因为列表允许多个单指令集合，所以管理器需要把这些单个对象组合成一个集合C返回。</li><li>跳转到B页面时，同样需要通过管理器创建指令，管理器发现这个单指令存在，那么就不要创建了，返回它的引用，这时候集合C的引用计数就是2。</li><li>B页面在销毁的时候引用计数-1，但是因为A页面的持有，集合C实际上引用计数还是1，不会释放，也就不会发送取消指令。</li></ol><p>看似可行的方案，实践中碰上了一些问题。按照MRC的规则，谁创建，谁释放，那么A页面在销毁的时候按理说集合C也要销毁，但是管理器也需要持有集合C，这样其它页面来请求指令的时候才能知道应该创建新的指令对象还是应该返回引用。但是管理器不应该强持有集合C，不然集合C就永远无法释放了。所以管理器在持有集合C的时候需要弱引用。这里用到了<code>NSHashTable</code>，它的用法和<code>NSArray</code>很相似，但是<code>NSHashTable</code>可以持有弱引用的对象。</p><p>所以博客到这里就写完了吗？当然没有。还有一个最大的发送取消集合C的指令的问题。服务器提供了一个批量取消单指令的指令，很适合集合C的场景。想法很简单，在集合C销毁的时候把它持有的单指令批量取消，就不需要一个个的去发送取消的指令了。那么问题来了，集合C怎么知道哪些单个指令需要取消，哪些不需要呢。而且集合C必须强持有它的单个指令，按照释放顺序，在集合C走到<code>deinit</code>方法的时候，它的属性是还能访问的。所以我们需要让集合C的单指令提前释放，并且还需要知道哪些单个指令需要发送取消指令，哪些不需要。核心代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class ListSubscribeObservation &#123;</span><br><span class="line">  //单订阅的数组</span><br><span class="line">  var children: [SingleSubscribeObservation]?</span><br><span class="line"></span><br><span class="line">  deinit() &#123;</span><br><span class="line">        //持有一份单指令的弱引用 然后让单指令集合提前释放</span><br><span class="line">        //如果弱引用还存在 那么说明还有地方在强应用这个单指令 那么不应该把它取消</span><br><span class="line"></span><br><span class="line">        let obsTable = NSHashTable&lt;SingleSubscribeObservation&gt;(options: [.weakMemory, .objectPointerPersonality], capacity: 0)</span><br><span class="line">        //要发送给服务器的指令集</span><br><span class="line">        var subKeys = [String]()</span><br><span class="line">        autoreleasepool &#123;</span><br><span class="line">            while let obj = self.children?.popLast() &#123;</span><br><span class="line">                obsTable.add(obj)</span><br><span class="line">                //这个标记用于表示是否应该发送取消指令</span><br><span class="line">                item.autoUnsub = false</span><br><span class="line">                subKeys.append(obj.value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //走到这里单指令集合应该已经被提前释放了 剩下的则不应该发送指令 将它移除出数组</span><br><span class="line">        for item in obsTable.objectEnumerator() &#123;</span><br><span class="line">            if let item = item as? SingleSubscribeObservation &#123;</span><br><span class="line">                //从批量释放中移除</span><br><span class="line">                if subKeys.contains(item.value) &#123;</span><br><span class="line">                    //恢复单订阅自动释放</span><br><span class="line">                    item.autoUnsub = true</span><br><span class="line">                    subKeys.remove(item.value)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if subKeys.count &gt; 0 &#123;</span><br><span class="line">          //发送订阅指令</span><br><span class="line">            let ws = WebSocket.shared</span><br><span class="line">            ws.removeKeys(subKeys)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>但是实际上在某些时候即使这样写，<code>children</code>仍然会在这个对象之后释放，所以最后的办法是在业务层加了延迟发送指令的代码。因为<code>children</code>最后一定会释放，它内部的单个指令也会快速释放，但是走的是单个释放的。所以做法是释放时通过定时器delay个0.1s，如果0.1s内再次走了这个方法，则把上一次的timer取消掉，否则执行批量释放，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class WebSocket &#123;</span><br><span class="line"></span><br><span class="line">// 临时需要移除订阅的数组</span><br><span class="line">private var tempRemoveKeys = Set&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">func removeKeys(_ keys: [String]) &#123;</span><br><span class="line">  if keys.count == 0 &#123;</span><br><span class="line">      return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //使用临时集合保存释放的key</span><br><span class="line">  self.tempRemoveKeys.formUnion(keys)</span><br><span class="line"></span><br><span class="line">  //短时间的批量释放合并到一起处理</span><br><span class="line">  self.removeDelayTimer?.invalidate()</span><br><span class="line">  self.removeDelayTimer = Timer.scheduledTimer(withTimeInterval: 0.2, block: &#123; [weak self] (_) in</span><br><span class="line">      guard let self = self else &#123;</span><br><span class="line">          return</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      let tempKeys = Array(self.tempRemoveKeys)</span><br><span class="line">      //发送取消指令</span><br><span class="line">      self.unsubKeys(tempKeys)</span><br><span class="line">      //移除临时集合</span><br><span class="line">      self.tempRemoveMarkets.removeAll()</span><br><span class="line">      &#125;, repeats: false)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实这个解决方案并不算好，导致调用时机没有按照预期执行的原因有待研究，这里对思考过程做一个记录。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;因为项目的一些历史原因，最近在进行重构，碰到了一些比较核心的订阅部分，写出来记录一下。&lt;/p&gt;
&lt;p&gt;订阅这个概念我是首先在RAC里见到。在</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>iOS的MobileVLCKit框架播放SMB协议视频的问题</title>
    <link href="https://github.com/sunsx9316/2018/08/26/iOS%E7%9A%84MobileVLCKit%E6%A1%86%E6%9E%B6%E6%92%AD%E6%94%BESMB%E5%8D%8F%E8%AE%AE%E8%A7%86%E9%A2%91%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://github.com/sunsx9316/2018/08/26/iOS%E7%9A%84MobileVLCKit%E6%A1%86%E6%9E%B6%E6%92%AD%E6%94%BESMB%E5%8D%8F%E8%AE%AE%E8%A7%86%E9%A2%91%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2018-08-26T10:46:38.209Z</published>
    <updated>2018-08-26T10:46:38.209Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://code.videolan.org/videolan/VLCKit">MobileVLCKit</a>是开源播放器VLC的iOS平台框架，在Mac OS上也有对应的VLCKit，搞直播的同学应该不陌生，不过它其实还是一款强大的本地播放器，支持几乎所有的主流媒体格式。最近在研究app如何浏览电脑上文件，然后直接做到播放视频的功能。用过iOS上的VLC播放器的童鞋应该知道，他能做到扫描本地端口，然后通过输入用户名和密码浏览电脑的文件，点击视频和音频还能直接播放。<br>通过Google知道这里用到一个叫SMB的协议，不光是Mac OS上，Windows和Linux都支持这种协议。只要本地开启SMB的文件共享服务，同一个局域网内的设备就能通过它访问电脑上的文件了。<br>上上<del>gayhub</del>发现了一个SMB的iOS框架，叫<a href="https://github.com/TimOliver/TOSMBClient">TOSMBClient</a>，它将一个C语言的框架封装成了OC的框架。还支持CocoaPods，使用起来非常方便。而<a href="https://code.videolan.org/videolan/VLCKit">MobileVLCKit</a>原生就支持SMB协议的在线播放。所以解决方案是通过TOSMBClient获取文件列表，VLC播放，想法很美好，但是实际实现还是踩了不少坑。</p><p>先说说SMB的格式，长这样：<code>smb://&#123;hostname&#125;:&#123;password&#125;@&#123;ip&#125;/path </code> 比如桌面上的一个mp4文件就应该长这样：<code>smb://xiaoming:123456@192.168.1.100/xiaoming/Desktop/233.mp4</code><br>hostname是域名，一般创建SMB共享协议的时候，就需要指定。password是密码，ip是服务器的ip。<br><a href="https://github.com/TimOliver/TOSMBClient">TOSMBClient</a>提供了一个登录的类叫<code>TOSMBSession</code>，常用属性是这几个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//服务器域名</span><br><span class="line">@property (nonatomic, copy) NSString *hostName;</span><br><span class="line">//服务器ip</span><br><span class="line">@property (nonatomic, copy) NSString *ipAddress;</span><br><span class="line">//登录的用户名</span><br><span class="line">@property (nonatomic, copy) NSString *userName;</span><br><span class="line">//登录密码</span><br><span class="line">@property (nonatomic, copy) NSString *password;</span><br></pre></td></tr></table></figure><p>其中域名和ip可以都设置，也可以只设置其中一个，框架会自动查找。<br>然后通过<code>TOSMBSession</code>提供的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)requestContentsOfDirectoryAtFilePath:(NSString *)path</span><br><span class="line">success:(void (^)(NSArray *files))successHandler</span><br><span class="line"> error:(void (^)(NSError *))errorHandler;</span><br></pre></td></tr></table></figure><p>获取文件列表，很简单。返回的files是<code>TOSMBSessionFile</code>类型。它包含基本的文件信息，比如路径，名称，大小。想法挺美好，有URL，直接给VLC播放不就行了，然后就碰到了<strong>第一个坑。</strong><br><code>TOSMBSessionFile</code>提供的路径只是smb格式的一部分，也就只有path部分，所以需要播放还得自己拼接成完整路径。</p><p>拼接好了之后尝试下播放个文件，没带中文的，成功了，高兴之余本着严谨的态度试了下中文路径，结果失败了。NSURL初始化如果包含标准ASCALL以外的字符，会返回nil，这是<strong>第二个坑。</strong></p><p>作为程序员，很自然会想到，URL如果带中文，浏览器会自动做URL转码。所以尝试下转码，发现还是播放失败。这就让我怀疑人生了，怎么肥事？而且连iOS上的VLC的app都有这个问题，这是<strong>第三个坑。</strong></p><p>通过查找API我发现播放器除了通过NSURL初始化，还可以通过NSString初始化，我想，NSURL不让包含中文，NSString总可以吧。结果还是播放失败，神奇的是即使不包含中文，通过NSString初始化还是失败，但是NSURL就可以，这是<strong>第四个坑。</strong></p><p>既然一定要实现功能，那就得搞明白为什么，这时候开源的好处就体现出来了，我看了下<a href="https://code.videolan.org/videolan/VLCKit">MobileVLCKit</a>的源码，它的媒体类<strong>VLCMedia</strong>是这么写的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithPath:(NSString *)aPath</span><br><span class="line">&#123;</span><br><span class="line">    return [self initWithURL:[NSURL fileURLWithPath:aPath isDirectory:NO]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithURL:(NSURL *)anURL</span><br><span class="line">&#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        const char *url;</span><br><span class="line">        VLCLibrary *library = [VLCLibrary sharedLibrary];</span><br><span class="line">        NSAssert(library.instance, @&quot;no library instance when creating media&quot;);</span><br><span class="line"></span><br><span class="line">        if (([[anURL absoluteString] hasPrefix:@&quot;sftp://&quot;]) ||</span><br><span class="line">            ([[anURL absoluteString] hasPrefix:@&quot;smb://&quot;])) &#123;</span><br><span class="line">            url = [[[anURL absoluteString] stringByRemovingPercentEncoding] UTF8String];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            url = [[anURL absoluteString] UTF8String];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p_md = libvlc_media_new_location(library.instance, url);</span><br><span class="line"></span><br><span class="line">        _metaDictionary = [[NSMutableDictionary alloc] initWithCapacity:3];</span><br><span class="line"></span><br><span class="line">        [self initInternalMediaDescriptor];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>initWithPath:</code>方法把字符串通过<code>fileURLWithPath:isDirectory:</code>方法初始化成URL了，所以smb格式的字符串路径通过这个方法初始化得到的路径肯定是错的，因为它不是标准的本地路径，自然会出现上面神奇的情况。<br>然后看下<code>initWithURL: </code>方法，if语句判断如果包含smb前缀，则做URL解码操作。说明我们的想法是正确的，确实应该对URL进行编码。但是，经过测试编码还是不行，这种情况就很费解了。到现在我还不知道什么原因，因为它自己的APP都有这个问题。不过之后偶然发现了解决方法，很简单<br>**<br>把URL编码两次即可！！<br>把URL编码两次即可！！<br>把URL编码两次即可！！<br>**</p><p>重要的事情说三遍，编码两次之后框架会对URL解码一次，所以得到的URL实际是编码了一次的内容，这样就能播放了，非常神奇，这是<strong>第五个坑。</strong>在这里分享一下给需要的童鞋。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>应该只对<code>path</code>、<code>hostname</code>、<code>password</code>部分做URL两次编码，<code>smb://</code>前缀不需要，否则播放器会无法识别。</p><p>2017.10.16日更新 如果发现拼接之后还是没法播放，大部分是因为VLC的版本比较旧的关系，cocoapods里有最新的unstable版本，用这个，不过这个版本也是最不稳定的。</p><p>2018.7.8日更新 <a href="https://github.com/sunsx9316/SMBPlayerDemo">文章Demo</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://code.videolan.org/videolan/VLCKit&quot;&gt;MobileVLCKit&lt;/a&gt;是开源播放器VLC的iOS平台框架，在Mac OS上也有对应的VLCKit，搞直播的同学应该不陌生，不过它其实还是一款强大的本地播放器，支</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>APP切换主题的一些思考</title>
    <link href="https://github.com/sunsx9316/2018/08/26/APP%E5%88%87%E6%8D%A2%E4%B8%BB%E9%A2%98%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <id>https://github.com/sunsx9316/2018/08/26/APP%E5%88%87%E6%8D%A2%E4%B8%BB%E9%A2%98%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</id>
    <published>2018-08-26T07:14:17.000Z</published>
    <updated>2019-08-17T03:01:07.739Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>APP内切换主题是比较常见的需要，蛮早就思考过这个问题。网上也有很多的解决方案，不过本质上其实都类似，无非是两种情况。</p><ul><li>如果需要实现类似手Q那样动态更换主题，那么主题一定是个配置文件，能够从服务器下载。</li><li>如果只要求能更换成本地的几套主题，那只通过代码初始化，写死也是可以的。</li></ul><p>说说两者的优缺点。</p><ul><li>第一种比较灵活，但是引入的配置文件肯定要求格式的通用，毕竟不太可能要求服务端针对不同的设备提供不同的配置。那么很多人或许会选择JSON或者XML之类的格式。这样就会导致可读性不那么好，也不太直观，而且也没办法在编译期就做代码检查。</li><li>第二种对比第一种就更直观，没有什么能比 <code>label.textColor = redColor</code> 这样的代码更易读了吧。同时因为是原生开发，也可以在编译期就做到代码检查，缺点就是灵活性差了些。</li></ul><p>所以要做的其实是选择适合自己的类型，还有如何能更简单的做到切换而已。这个轮子其实并不太适合项目，更多是作为思考。公司项目并不要求做到类似手Q那样动态切换主题，但是为了拓展性，我还是考虑通过配置文件去加载。</p><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>因为写主题配置是十分麻烦的事，我想要做到的效果是只写配置文件，代码里不需要写任何判断和设置的逻辑就能做到自动根据当前主题切换样式。所以要做的事分为以下几步：</p><ol><li>书写配置</li><li>程序读取配置</li><li>代码根据当前主题自动设置样式</li></ol><p>同时配置文件要求可读性良好，就算别人接手了这个模块也不需要熟悉特定的配置书写语法。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>因为是本地使用，那么可以不考虑通用性，为了开发简单，我们使用<code>Plist</code>写配置。为了可读性良好，且尽量不增加学习成本，我想做到最好写在配置里的就是类似 <code>label.textColor = redColor</code> 这样的赋值语句。那能不能做到这一点呢，当然可以，我们可以借助OC的KVC。KVC本身也支持keyPath这样的赋值方式，<code>&quot;label.textColor&quot;</code> 这样的字符串在KVC中会被解析成查找 <code>label</code> 下的 <code>textColor</code> 属性。所以我们在 <code>Plist</code> 里的 <code>key</code>就可以定义成 <code>&quot;label.textColor&quot;</code>，而 <code>value</code>就是颜色。</p><p>那么问题来了，<code>Plist</code> 只支持字符串、数字、日期、二进制流这几种有限的格式，那怎么让它支持颜色呢？很容易联想到颜色16进制的表示方式，比如白色使用16进制表示就是 <code>#FFFFFF</code>，所以直接使用字符串不就好了。但是问题没这么简单。</p><p>一种比较常见的需求是在不同的主题下需要显示不同图片 (比如我们就有白天和黑夜模式，黑夜模式的图片就要求暗一些。小声bb……)，颜色如果使用了 <code>#FFFFFF</code> 这样的方式设置，那么图片怎么办？图片可以根据图片名，但是程序需要知道这个字符串是什么才能把它转成对应的东西，所以就需要定一套简单的规则了。</p><p>字符串非常灵活，任意的组合可以得到完全不同的内容，所以对于这种情况，选择字符串类型是比较合适的。类似编译器，有一套自己的复杂的解析规则，会把字符串转换为语法树。我们不需要这么复杂，只是简单的格式就好，但是可以设计成拥有很强拓展性的模式。所以我们需要定义一些通用的接口，生成一些解析器，这会在第二步详细说明。</p><h3 id="读取配置"><a href="#读取配置" class="headerlink" title="读取配置"></a>读取配置</h3><p>这一步比较重要的是接口的设计，关乎到使用的方便性和未来的拓展性。</p><p>我们接着说第一步末尾说到的解析器。为什么要定义解析器呢？首先每一个 <code>Plist</code>的对象，值传过来都是个字符串，我们要根据里面字符串的格式判断它是应该解析成颜色，或者图片又或者是其它。每种情况都不一样，所以拆分成独立的解析器会更好。不过他们都用一个共同点，遵守同一个协议。协议我们这样定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 解析优先级</span><br><span class="line"></span><br><span class="line"> - JHThemeParserPriorityRequest: 最先解析</span><br><span class="line"> - JHThemeParserPriorityNormal: 普通</span><br><span class="line"> - JHThemeParserPriorityUnimportance: 最后解析</span><br><span class="line"> */</span><br><span class="line">typedef NS_ENUM(NSUInteger, JHThemeParserPriority) &#123;</span><br><span class="line">    JHThemeParserPriorityUnimportance,</span><br><span class="line">    JHThemeParserPriorityNormal,</span><br><span class="line">    JHThemeParserPriorityRequest = 1000,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@class JHTheme;</span><br><span class="line">@protocol JHThemeParserProtocol &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 解析优先级</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, assign, readonly) JHThemeParserPriority priority;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 唯一标识</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, copy, readonly) NSString *identify;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 是否在解析之后直接返回 YES会将解析结果让之后的解析器继续解析</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, assign, readonly) BOOL continueParse;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 是否能解析这个值</span><br><span class="line"></span><br><span class="line"> @param value 值</span><br><span class="line"> @return 是否能解析这个值</span><br><span class="line"> */</span><br><span class="line">- (BOOL)canParseValue:(id)value;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 解析具体实现</span><br><span class="line"></span><br><span class="line"> @param value 值</span><br><span class="line"> @param currentTheme 当前主题</span><br><span class="line"> @return 解析结果</span><br><span class="line"> */</span><br><span class="line">- (id)converValue:(id)value currentTheme:(JHTheme *)currentTheme;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重要的是这两个方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)canParseValue:(id)value;</span><br><span class="line">- (id)converValue:(id)value currentTheme:(JHTheme *)currentTheme;</span><br></pre></td></tr></table></figure><p>第一个方法判断这个解析器能否解析这个字符串。</p><ul><li>如果返回 <code>true</code> ， 那么会接着调用<code>converValue:(id)value currentTheme:(JHTheme *)currentTheme</code>，让解析器自己内部进行解析。</li><li>如果返回 <code>false</code>，那么这个解析器就无法解析这个字符串，也不会有之后的调用了。</li></ul><p>举个简单的例子，这是颜色解析器内部的实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@implementation JHThemeColorParser</span><br><span class="line">- (BOOL)canParseValue:(NSString *)value &#123;</span><br><span class="line">    if ([value isKindOfClass:[NSString class]] &amp;&amp; ([value hasPrefix:@&quot;c(&quot;] || [value hasPrefix:@&quot;C(&quot;]) &amp;&amp; [value hasSuffix:@&quot;)&quot;]) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)converValue:(NSString *)value currentTheme:(JHTheme *)currentTheme &#123;</span><br><span class="line">    //取出色值</span><br><span class="line">    value = [value substringWithRange:NSMakeRange(2, value.length - 3)];</span><br><span class="line">    NSArray &lt;NSString *&gt;*rgba = [value componentsSeparatedByString:@&quot;,&quot;];</span><br><span class="line">    //16进制</span><br><span class="line">    if (rgba.count == 1) &#123;</span><br><span class="line">        return [UIColor colorWithHexString:value];</span><br><span class="line">    &#125;</span><br><span class="line">    else if (rgba.count &gt;= 3) &#123;</span><br><span class="line">        CGFloat r = 0,g = 0,b = 0,a = 1;</span><br><span class="line">        r = rgba.firstObject.doubleValue / 255.0;</span><br><span class="line">        g = rgba[1].doubleValue / 255.0;</span><br><span class="line">        b = rgba[2].doubleValue / 255.0;</span><br><span class="line">        if (rgba.count &gt;= 4) &#123;</span><br><span class="line">            a = rgba[3].doubleValue;</span><br><span class="line">        &#125;</span><br><span class="line">        return [UIColor colorWithRed:r green:g blue:b alpha:a];</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>首先 <code>- (BOOL)canParseValue:(id)value</code> 这个方法的实现是判断值是否符合规则，这里我定义成符合 <code>c(#FFFFF)</code> 或者 <code>c(255,255,255)</code> 格式的字符串就可以解析。前者是颜色的16进制表示法，后者是通过指定RGB数字的颜色表示法。而下面只是对这个解析格式的实现而已。这样做的好处是如果想定义一套比较复杂的解析规则，只要实现协议，自己写解析逻辑就好了。比如除了颜色的，我还实现了一些类似宏的解析逻辑。像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)canParseValue:(NSString *)value &#123;</span><br><span class="line">    if ([value isKindOfClass:[NSString class]] &amp;&amp; ([value hasPrefix:@&quot;d(&quot;] || [value hasPrefix:@&quot;D(&quot;]) &amp;&amp; [value hasSuffix:@&quot;)&quot;]) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)converValue:(NSString *)value currentTheme:(JHTheme *)currentTheme &#123;</span><br><span class="line">    NSString *tempStr = [[value substringWithRange:NSMakeRange(2, value.length - 3)] stringByTrim];</span><br><span class="line">    NSDictionary *mapDic = currentTheme.defineMap;</span><br><span class="line">    id map = mapDic[tempStr];</span><br><span class="line">    if (map) &#123;</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)continueParse &#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (JHThemeParserPriority)priority &#123;</span><br><span class="line">    return JHThemeParserPriorityRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>场景是APP有一个主题色，如果按照上面只是通过指定颜色去写，那就会很麻烦，而且一旦主题色更换，也要全局修改。这个宏解析器就定义了一种字符串格式像这样 <code>d(mainColor)</code>。配置文件有一个独立的”宏字典”，解析器取出 <code>mainColor</code> 然后在”宏字典”里查找 <code>mainColor</code>对应的 <code>value</code>是什么，这个 <code>value</code> 我只要定义成<code>c(#FFFFF)</code> 或者其它解析器可以解析的格式，就可以做到类似宏定义的替换效果。需要注意的是 <code>- (BOOL)continueParse</code> 需要返回 <code>YES</code>，这样解析的结果才能返回给其它的解析器继续解析。</p><p>所以可以看到，这样是非常灵活的。</p><h3 id="自动设置样式"><a href="#自动设置样式" class="headerlink" title="自动设置样式"></a>自动设置样式</h3><p>这一步其实相对来说比较容易了，但是也有不少值得说的地方。我这里定义了一个叫 <code>themeManager</code> 的主题管理类。接口这样设计：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 自定义操作block</span><br><span class="line"></span><br><span class="line"> @param aObj 更改的对象</span><br><span class="line"> @param key 键</span><br><span class="line"> @param value 值</span><br><span class="line"> @return 自定义更改的对象</span><br><span class="line"> */</span><br><span class="line">typedef id(^JHThemeCustomAction)(id aObj, NSString *key, id value);</span><br><span class="line"></span><br><span class="line">@class JHThemeManager;</span><br><span class="line">@protocol JHThemeManagerObserver&lt;NSObject&gt;</span><br><span class="line">@optional</span><br><span class="line">//主题改变回调</span><br><span class="line">- (void)themeManager:(JHThemeManager *)themeManager didChangeTheme:(JHTheme *)theme;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface JHThemeManager : NSObject</span><br><span class="line">+ (instancetype)shareThemeManager;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong, readonly) JHTheme *currentTheme;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 注册自定义解析器</span><br><span class="line"></span><br><span class="line"> @param parserClass 解析器需要实现 JHThemeParserProtocol接口</span><br><span class="line"> */</span><br><span class="line">- (void)registerParser:(Class)parserClass;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 添加单个主题</span><br><span class="line"></span><br><span class="line"> @param theme 主题对象</span><br><span class="line"> */</span><br><span class="line">- (void)addTheme:(JHTheme *)theme;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 添加多个主题</span><br><span class="line"></span><br><span class="line"> @param themes 主题数组</span><br><span class="line"> */</span><br><span class="line">- (void)addThemes:(NSArray &lt;JHTheme *&gt;*)themes;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 根据主题名称更改当前主题</span><br><span class="line"></span><br><span class="line"> @param themeName 主题名称</span><br><span class="line"> */</span><br><span class="line">- (void)updateThemeByName:(NSString *)themeName;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 根据当前主题更新对象的样式</span><br><span class="line"></span><br><span class="line"> @param obj 对象</span><br><span class="line"> @param themeKey 主题下的Key 空则为obj的类名</span><br><span class="line"> @param block 自定义操作</span><br><span class="line"> */</span><br><span class="line">- (void)updateObjStyleWithCurrentTheme:(id)obj</span><br><span class="line">                              themeKey:(NSString *)themeKey</span><br><span class="line">                                 block:(JHThemeCustomAction)block;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 根据当前主题更新对象的样式</span><br><span class="line"></span><br><span class="line"> @param obj 对象</span><br><span class="line"> @param themeKey 主题下的Key 空则为obj的类名</span><br><span class="line"> @param themeName 主题名称</span><br><span class="line"> @param block 自定义操作</span><br><span class="line"> */</span><br><span class="line">- (void)updateObjStyleWithCurrentTheme:(id)obj</span><br><span class="line">                              themeKey:(NSString *)themeKey</span><br><span class="line">                             themeName:(NSString *)themeName</span><br><span class="line">                                 block:(JHThemeCustomAction)block;</span><br><span class="line"></span><br><span class="line">- (void)addObserver:(id&lt;JHThemeManagerObserver&gt;)observer;</span><br><span class="line">- (void)removeObserver:(id&lt;JHThemeManagerObserver&gt;)observer;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><code>- (void)registerParser:(Class)parserClass</code> 注册的是遵守了解析器协议的类，只有注册了才支持解析这种类型的字符串。内部实现是通过数组保存示例，解析的时候根据优先级循环调用已经注册的解析器进行解析。</p><p>然后重点是自动。因为我们的 <code>key</code> 是 <code>keyPath</code>的形式，所以直接通过KVC把解析结果赋值就行。</p><p>实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line">- (void)updateObjStyleWithCurrentTheme:(id)toObj</span><br><span class="line">                              themeKey:(NSString *)themeKey</span><br><span class="line">                             themeName:(NSString *)themeName</span><br><span class="line">                                 block:(JHThemeCustomAction)block &#123;</span><br><span class="line">    if (toObj == nil) return;</span><br><span class="line"></span><br><span class="line">    if (themeKey.length == 0) &#123;</span><br><span class="line">        themeKey = NSStringFromClass([toObj class]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    JHTheme *aTheme = nil;</span><br><span class="line">    if (themeName.length == 0) &#123;</span><br><span class="line">        aTheme = self.currentTheme;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        aTheme = [self themeByName:themeName];</span><br><span class="line">    &#125;</span><br><span class="line">    //获取当前主题所有存储的内容</span><br><span class="line">    NSDictionary *content = aTheme.content[themeKey];</span><br><span class="line">    if ([content isKindOfClass:[NSDictionary class]] == NO) return;</span><br><span class="line"></span><br><span class="line">    [content enumerateKeysAndObjectsUsingBlock:^(NSString * _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123;</span><br><span class="line"></span><br><span class="line">        //自定义修改</span><br><span class="line">        if (block) &#123;</span><br><span class="line">            obj = block(toObj, key, [self converValueWithObj:obj]);</span><br><span class="line">            if (obj == nil) return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NSString *cacheKey = [themeKey stringByAppendingFormat:@&quot;.%@&quot;, key];</span><br><span class="line">        NSNumber *cache = [self.keyPathCache objectForKey:cacheKey];</span><br><span class="line">        //没有缓存过</span><br><span class="line">        if (cache == nil) &#123;</span><br><span class="line">            NSArray &lt;NSString *&gt;*keyPaths = [key componentsSeparatedByString:@&quot;.&quot;];</span><br><span class="line"></span><br><span class="line">            id lastObj = toObj;</span><br><span class="line"></span><br><span class="line">            //单个key</span><br><span class="line">            if (keyPaths.count == 1) &#123;</span><br><span class="line">                //当前key不存在</span><br><span class="line">                BOOL exist = [lastObj respondsToSelector:NSSelectorFromString(keyPaths.firstObject)];</span><br><span class="line">                NSAssert(exist, @&quot;%@不存在 设置主题失败&quot;, key);</span><br><span class="line"></span><br><span class="line">                if (exist == false) &#123;</span><br><span class="line">                    cache = @(NO);</span><br><span class="line">                    [self.keyPathCache setObject:cache forKey:cacheKey];</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    cache = @(YES);</span><br><span class="line">                    [self.keyPathCache setObject:cache forKey:cacheKey];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //keyPath</span><br><span class="line">            else &#123;</span><br><span class="line">                BOOL flag = YES;</span><br><span class="line">                for (NSInteger i = 0; i &lt; keyPaths.count - 1; ++i) &#123;</span><br><span class="line">                    NSString *key = keyPaths[i];</span><br><span class="line">                    SEL selector = NSSelectorFromString(key);</span><br><span class="line">                    if ([lastObj respondsToSelector:selector]) &#123;</span><br><span class="line">                        lastObj = [lastObj valueForKey:key];</span><br><span class="line">                    &#125;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        flag = NO;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (flag) &#123;</span><br><span class="line">                    flag = [lastObj respondsToSelector:NSSelectorFromString(keyPaths.lastObject)];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                cache = @(flag);</span><br><span class="line">                [self.keyPathCache setObject:cache forKey:cacheKey];</span><br><span class="line">                if (flag == NO) &#123;</span><br><span class="line">                    NSLog(@&quot;%@不存在 设置主题失败&quot;, key);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //key无效</span><br><span class="line">        if (cache.boolValue == NO) return;</span><br><span class="line"></span><br><span class="line">        //多参数</span><br><span class="line">        if ([key containsString:@&quot;:&quot;]) &#123;</span><br><span class="line">            NSArray *separatedValues = [key componentsSeparatedByString:@&quot;.&quot;];</span><br><span class="line">            NSString *method = separatedValues.lastObject;</span><br><span class="line">            SEL aSEL = NSSelectorFromString(method);</span><br><span class="line">            //真正发消息的对象</span><br><span class="line">            id sendObj = [toObj valueForKeyPath:[key stringByReplacingOccurrencesOfString:[NSString stringWithFormat:@&quot;.%@&quot;, method] withString:@&quot;&quot;]];</span><br><span class="line"></span><br><span class="line">            NSArray *valueArr = [obj isKindOfClass:[NSArray class]] ? obj : @[obj];</span><br><span class="line">            YYClassMethodInfo *info = [[YYClassMethodInfo alloc] initWithMethod:class_getInstanceMethod([sendObj class], aSEL)];</span><br><span class="line">            //冒号之后的参数为实际参数</span><br><span class="line">            NSArray &lt;NSString *&gt;*argumentTypeEncodings = ^&#123;</span><br><span class="line">                NSInteger index = [info.argumentTypeEncodings indexOfObject:@&quot;:&quot;];</span><br><span class="line">                if (index != NSNotFound) &#123;</span><br><span class="line">                    return (NSArray *)[info.argumentTypeEncodings subarrayWithRange:NSMakeRange(index + 1, info.argumentTypeEncodings.count - index - 1)];</span><br><span class="line">                &#125;</span><br><span class="line">                return @[];</span><br><span class="line">            &#125;();</span><br><span class="line"></span><br><span class="line">            //参数个数和key的方法不一致</span><br><span class="line">            if (argumentTypeEncodings.count != valueArr.count) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            NSMethodSignature *sign = [sendObj methodSignatureForSelector:aSEL];</span><br><span class="line">            NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:sign];</span><br><span class="line">            invocation.target = sendObj;</span><br><span class="line">            invocation.selector = aSEL;</span><br><span class="line"></span><br><span class="line">            for (NSInteger idx1 = 0; idx1 &lt; argumentTypeEncodings.count; ++idx1) &#123;</span><br><span class="line">                id obj1 = valueArr[idx1];</span><br><span class="line">                id tempObj = [self converValueWithObj:obj1];</span><br><span class="line">                YYEncodingType encodingType = YYEncodingGetType(argumentTypeEncodings[idx1].UTF8String);</span><br><span class="line">                switch (encodingType) &#123;</span><br><span class="line">                    case YYEncodingTypeBool:</span><br><span class="line">                    &#123;</span><br><span class="line">                        BOOL aValue = [tempObj boolValue];</span><br><span class="line">                        [invocation setArgument:&amp;aValue atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case YYEncodingTypeInt8:</span><br><span class="line">                    &#123;</span><br><span class="line">                        char aValue = [tempObj charValue];</span><br><span class="line">                        [invocation setArgument:&amp;aValue atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case YYEncodingTypeUInt8:</span><br><span class="line">                    &#123;</span><br><span class="line">                        unsigned char aValue = [tempObj unsignedCharValue];</span><br><span class="line">                        [invocation setArgument:&amp;aValue atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case YYEncodingTypeInt16:</span><br><span class="line">                    &#123;</span><br><span class="line">                        short aValue = [tempObj shortValue];</span><br><span class="line">                        [invocation setArgument:&amp;aValue atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case YYEncodingTypeUInt16:</span><br><span class="line">                    &#123;</span><br><span class="line">                        unsigned short aValue = [tempObj unsignedShortValue];</span><br><span class="line">                        [invocation setArgument:&amp;aValue atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case YYEncodingTypeInt32:</span><br><span class="line">                    &#123;</span><br><span class="line">                        int32_t aValue = [tempObj intValue];</span><br><span class="line">                        [invocation setArgument:&amp;aValue atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case YYEncodingTypeUInt32:</span><br><span class="line">                    &#123;</span><br><span class="line">                        uint32_t aValue = [tempObj intValue];</span><br><span class="line">                        [invocation setArgument:&amp;aValue atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case YYEncodingTypeInt64:</span><br><span class="line">                    &#123;</span><br><span class="line">                        long long aValue = [tempObj longLongValue];</span><br><span class="line">                        [invocation setArgument:&amp;aValue atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case YYEncodingTypeUInt64:</span><br><span class="line">                    &#123;</span><br><span class="line">                        unsigned long long aValue = [tempObj unsignedLongLongValue];</span><br><span class="line">                        [invocation setArgument:&amp;aValue atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case YYEncodingTypeFloat:</span><br><span class="line">                    &#123;</span><br><span class="line">                        float aValue = [tempObj floatValue];</span><br><span class="line">                        [invocation setArgument:&amp;aValue atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case YYEncodingTypeDouble:</span><br><span class="line">                    &#123;</span><br><span class="line">                        double aValue = [tempObj doubleValue];</span><br><span class="line">                        [invocation setArgument:&amp;aValue atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case YYEncodingTypeLongDouble:</span><br><span class="line">                    &#123;</span><br><span class="line">                        long double aValue = [tempObj doubleValue];</span><br><span class="line">                        [invocation setArgument:&amp;aValue atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case YYEncodingTypeObject:</span><br><span class="line">                    &#123;</span><br><span class="line">                        [invocation setArgument:&amp;tempObj atIndex:idx1 + 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    default:</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //调用</span><br><span class="line">            [invocation invoke];</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            [toObj setValue:[self converValueWithObj:obj] forKeyPath:key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么长一段代码，我都不想看😑，幸好还记得怎么实现的。按照上面我们说的，应该非常简单才对，但是实际上还要处理一些其他情况。举个例子，<code>UIButton</code> 在设置图片、文字颜色等属性的时候需要带上 <code>UIControlState</code>，那就需要传两个参数。<code>Plist</code>可以把这种多参数保存为数组，但是KVC就没办法做到赋值了，这时候就要借助到OC的运行时了。</p><p>我们知道，OC的方法调用，本质都是发送消息，而消息的参数是不确定的，所以我们可以借助底层提供的 <code>NSInvocation</code> 这种通过方法签名发消息的类。如果了解过OC的消息转发机制的同学，应该见过这个类。它其实是一个调用器，设置了方法签名，再设置了参数就可以像普通消息发送了。方法名我们定义成配置的 <code>key</code>，多参数就和OC的方法名一样，用”:”隔开，类似这样：<code>setImage:forState</code>，<code>value</code> 是一个数组。实现用了YYKit的一些方法，只是写起来简单一些，内部就是调用runtime的API，这样就做到了多参数的兼容。</p><p>然而实际使用的时候，其实很麻烦。有一个比较巧妙的方式是通过分类去添加参数。比如 <code>UIButton</code> 的 <code>setImage:forState</code>，我们可以添加这些分类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) UIImage *jh_normalImg;</span><br><span class="line">@property (nonatomic, strong) UIImage *jh_hightlightedImg;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>实现是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)setJh_normalImg:(UIImage *)jh_normalImg &#123;</span><br><span class="line">    [self setImage:jh_normalImg forState:UIControlStateNormal];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIImage *)jh_normalImg &#123;</span><br><span class="line">    return [self imageForState:UIControlStateNormal];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setJh_hightlightedImg:(UIImage *)jh_hightlightedImg &#123;</span><br><span class="line">    [self setImage:jh_hightlightedImg forState:UIControlStateHighlighted];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIImage *)jh_hightlightedImg &#123;</span><br><span class="line">    return [self imageForState:UIControlStateHighlighted];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过分类指定其它的参数就可以像单个参数那样使用了。</p><p>至于自动调用，其实很简单。我们给 <code>NSObject</code> 添加一个分类，实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@implementation NSObject (JHThemeManager)</span><br><span class="line"></span><br><span class="line">- (void)jh_updateTheme &#123;</span><br><span class="line">    [self jh_updateThemeByKey:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)jh_updateThemeByKey:(NSString *)key &#123;</span><br><span class="line">    [self jh_updateThemeByKey:key block:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)jh_updateThemeByKey:(NSString *)key</span><br><span class="line">                      block:(JHThemeCustomAction)block &#123;</span><br><span class="line">    [self jh_updateThemeByKey:key theme:nil block:block];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)jh_updateThemeByKey:(NSString *)key</span><br><span class="line">                      theme:(NSString *)theme</span><br><span class="line">                      block:(JHThemeCustomAction)block &#123;</span><br><span class="line">    [[JHThemeManager shareThemeManager] updateObjStyleWithCurrentTheme:self themeKey:key themeName:theme block:block];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>其实也只不过是对 <code>[[JHThemeManager shareThemeManager] updateObjStyleWithCurrentTheme:self themeKey:key themeName:theme block:block];</code> 的封装，这个key是配置里的 <code>key</code>，一般定义成类名。<code>theme</code> 就是主题的名字，传 <code>nil</code>的话就获取当前主题。然后创建在你的控制器基类、各种View的基类中合适的时机调用 <code>- (void)jh_updateTheme</code> 就会自动在生成时进行主题设置。</p><p>配置文件是这样的：<br><img src="/sunsx9316/APP%E5%88%87%E6%8D%A2%E4%B8%BB%E9%A2%98%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/img.jpg" alt="img"></p><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>实际使用中，这个轮子并不太方便。一是因为代码都在 <code>Plist</code> 里，不能非常直观的看到样式的设置过程。而且要求key与类中的属性，代码一旦有修改，<code>Plist</code>也需要做修改。最重要的一点是 <code>Value</code> 字符串的书写不能出错，但这是不太容易的，因为人就是个Bug。</p><p>比较好的解决方式就是写个GUI工具，能浏览和生成配置，而不是通过手工添加。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;APP内切换主题是比较常见的需要，蛮早就思考过这个问题。网上也有很多的解决方案，不过本质上其实都类似，无非是两种情况。&lt;/p&gt;
&lt;ul&gt;
&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>UITableView+FDTemplateLayoutCell计算行高一些缺陷的解决方法</title>
    <link href="https://github.com/sunsx9316/2018/08/26/UITableView-FDTemplateLayoutCell%E8%AE%A1%E7%AE%97%E8%A1%8C%E9%AB%98%E4%B8%80%E4%BA%9B%E7%BC%BA%E9%99%B7%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://github.com/sunsx9316/2018/08/26/UITableView-FDTemplateLayoutCell%E8%AE%A1%E7%AE%97%E8%A1%8C%E9%AB%98%E4%B8%80%E4%BA%9B%E7%BC%BA%E9%99%B7%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</id>
    <published>2018-08-25T18:27:38.000Z</published>
    <updated>2018-12-15T18:00:02.338Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>UITableView动态行高一直是iOS的一个经典问题，在没有AutoLayout的时代，只能自己计算<strong>frame</strong>，然后返回给代理，非常痛苦。到了AutoLayout的时代，布局就变得简单多了，甚至于通过系统提供的API都能自动计算出行高。</p><p><a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell">UITableView+FDTemplateLayoutCell</a>就是<a href="https://github.com/sunnyxx">sunnyxx</a>大大的一个自动计算行高的框架。只要布局正确，通过它可以自动计算并缓存行高，非常方便。不过在使用上发现一些问题，也尝试去解决了。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>需求是这样的，一个类似微博的页面，像这样：<br><img src="/sunsx9316/UITableView-FDTemplateLayoutCell%E8%AE%A1%E7%AE%97%E8%A1%8C%E9%AB%98%E4%B8%80%E4%BA%9B%E7%BC%BA%E9%99%B7%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/1320218-1fc431e9a8a7a4f9.jpg" alt="微博图片"></p><p>这应该是比较经典的布局，内容和图片都是不确定的，行高要根据实际数据计算。九宫格实现方式有很多，我这里是通过UICollectionView去实现的。这样的一个好处就是UICollectionView的高度可以通过它的<strong>collectionViewLayout</strong>对象获取，啥都不用算。不过会有一个问题，UICollectionView继承自UIScrollView，它的高度没法按照内容来全显示。所以即使布局正确，通过AutoLayout来计算行高也是不包括UICollectionView的，这个问题同样反映在一些UIView控件上。</p><p>这就十分蛋疼了，难道还要回到手算frame的时代？当然不是，是我还写啥博客。</p><p>我说下解决的几个方法。</p><p><strong>方法一（不推荐）</strong>：手动设置collectionView的高度，可以通过代码或者xib来设置，我这里是xib。</p><p><img src="/sunsx9316/UITableView-FDTemplateLayoutCell%E8%AE%A1%E7%AE%97%E8%A1%8C%E9%AB%98%E4%B8%80%E4%BA%9B%E7%BC%BA%E9%99%B7%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/1320218-decdeddd6bfaee61.png" alt="xib"></p><p>像这样手动指定collectionView的高度，然后赋值数据源的时候更新collectionView高度约束就可以了，让它的高度等于它的<strong>contentSize.height</strong>，这样就能全部显示了，其它UIView控件也能这么解决。但是这样在计算行高的时候会抛出非常多异常，都是约束的问题。我不是很清楚这是什么原因，按理说计算再后，赋值在前，应该不会这样。而且显示会出一些问题，计算的行高会不正确，有些许误差。</p><p><strong>方法二（推荐）</strong>：既然不能通过这种方式，那就绕个弯吧。去掉高度约束，计算出来的高就不包含collectionView的高。然后再手动加上collectionView的高返回给代理不就行了。不过看下<a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell">UITableView+FDTemplateLayoutCell</a>的拓展方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier</span><br><span class="line">configuration:(void (^)(id cell))configuration;</span><br></pre></td></tr></table></figure><p>只有一个设置cell数据源的block，正常情况下我们只需要把cell换成我们自己的类，然后赋值模型就行，缓存之类的框架会自动处理好。虽然我们可以获取到缓存高度之后再加上collectionView的高，但是这样还叫啥缓存，缓存就是不需要计算，直接取到就能用，那怎么办呢？<br>虽然可以通过<strong>Method Swizzling</strong>黑魔法交换方法实现，但是这并不是最优方法，往往是一些莫名其妙的bug的源泉，作为开发者应该尽量避免这种方式。所以最后我选择了通过分类的方式。思路是在框架计算完高度之后通过block返回，我们自行处理行高，加加减减，然后返回高度让框架缓存。<br>具体代码：<br>我们参考下框架这个方法的实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier</span><br><span class="line">cacheByIndexPath:(NSIndexPath *)indexPath</span><br><span class="line">configuration:(void (^)(id cell))configuration &#123;</span><br><span class="line">if (!identifier || !indexPath) &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//命中缓存</span><br><span class="line">if ([self.fd_indexPathHeightCache existsHeightAtIndexPath:indexPath]) &#123;</span><br><span class="line">[self fd_debugLog:[NSString stringWithFormat:@&quot;hit cache by index path[%@:%@] - %@&quot;, @(indexPath.section), @(indexPath.row), @([self.fd_indexPathHeightCache heightForIndexPath:indexPath])]];</span><br><span class="line">return [self.fd_indexPathHeightCache heightForIndexPath:indexPath];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//计算行高</span><br><span class="line">CGFloat height = [self fd_heightForCellWithIdentifier:identifier configuration:configuration];</span><br><span class="line">[self.fd_indexPathHeightCache cacheHeight:height byIndexPath:indexPath];</span><br><span class="line">[self fd_debugLog:[NSString stringWithFormat: @&quot;cached by index path[%@:%@] - %@&quot;, @(indexPath.section), @(indexPath.row), @(height)]];</span><br><span class="line"></span><br><span class="line">return height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它先从缓存中寻找行高，命中之后直接返回。否则计算行高，存入缓存，然后返回。所以很简单，我们可以直接复制它的代码。写一个带编辑行高功能的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">typedef CGFloat(^editCellHeightAction)(id cell, CGFloat cellHeight);</span><br><span class="line"></span><br><span class="line">- (CGFloat)jh_heightForCellWithIdentifier:(NSString *)identifier</span><br><span class="line">cacheByIndexPath:(NSIndexPath *)indexPath</span><br><span class="line">configuration:(void (^)(id cell))configuration</span><br><span class="line">editAction:(editCellHeightAction)editAction &#123;</span><br><span class="line">if (!identifier || !indexPath) &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">// Hit cache</span><br><span class="line">if ([self.fd_indexPathHeightCache existsHeightAtIndexPath:indexPath]) &#123;</span><br><span class="line">[self fd_debugLog:[NSString stringWithFormat:@&quot;hit cache by index path[%@:%@] - %@&quot;, @(indexPath.section), @(indexPath.row), @([self.fd_indexPathHeightCache heightForIndexPath:indexPath])]];</span><br><span class="line">return [self.fd_indexPathHeightCache heightForIndexPath:indexPath];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CGFloat height = 0;</span><br><span class="line">//获取缓存中的cell</span><br><span class="line">UITableViewCell *templateLayoutCell = [self fd_templateCellForReuseIdentifier:identifier];</span><br><span class="line">//这里插入编辑行高的代码</span><br><span class="line">if (editAction) &#123;</span><br><span class="line">height = editAction(templateLayoutCell, [self fd_heightForCellWithIdentifier:identifier configuration:configuration]);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">height = [self fd_heightForCellWithIdentifier:identifier configuration:configuration];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[self.fd_indexPathHeightCache cacheHeight:height byIndexPath:indexPath];</span><br><span class="line">[self fd_debugLog:[NSString stringWithFormat: @&quot;cached by index path[%@:%@] - %@&quot;, @(indexPath.section), @(indexPath.row), @(height)]];</span><br><span class="line">return height;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用起来像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (CGFloat)tableView:(UITableView *)tableView</span><br><span class="line">heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">return [tableView jh_heightForCellWithIdentifier:@&quot;MineCell&quot; cacheByIndexPath:indexPath configuration:^(HeSquareCell *cell) &#123;</span><br><span class="line">//正常赋值数据源</span><br><span class="line">cell.model = self.model;</span><br><span class="line">&#125; editAction:^CGFloat(MineCell *cell, CGFloat cellHeight) &#123;</span><br><span class="line">//cellHeight是上面的block计算后回调过来的 所以直接加上额外的高度即可</span><br><span class="line">//因为缓存的关系这里只会走一次 所以可以放心写</span><br><span class="line">return cellHeight + [cell collectionViewHeightWithModel:self.model];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样高度就能正常显示了，而且也不会抛异常，还能享受框架带来的便利。<br><a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell">UITableView+FDTemplateLayoutCell</a>的接口设计很易于拓展，所以写起来很简单。还有个问题，我发现在使用这个框架的时候，如果<code>_tableView.tableFooterView = [[UIView alloc] init];</code>这句话写在注册cell之前，程序会crash，不造为啥。如果各位有更好的解决思路或者文中有错误的地方欢迎给我留言。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;UITableView动态行高一直是iOS的一个经典问题，在没有AutoLayout的时代，只能自己计算&lt;strong&gt;frame&lt;/str</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="https://github.com/sunsx9316/2018/08/26/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>https://github.com/sunsx9316/2018/08/26/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</id>
    <published>2018-08-25T16:55:41.870Z</published>
    <updated>2018-08-25T16:55:41.870Z</updated>
    
    <content type="html"><![CDATA[<p>最近决定要开始写博客了，打算先把简书的搬过来。这一年接触了很多东西，觉得需要记录下来，自己搭博客还蛮有意思的:)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近决定要开始写博客了，打算先把简书的搬过来。这一年接触了很多东西，觉得需要记录下来，自己搭博客还蛮有意思的:)&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
