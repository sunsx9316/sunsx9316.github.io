<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jim Huang的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/sunsx9316/"/>
  <updated>2018-08-25T17:59:32.471Z</updated>
  <id>https://github.com/sunsx9316/</id>
  
  <author>
    <name>Jim Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UITableView+FDTemplateLayoutCell计算行高一些缺陷的解决方法</title>
    <link href="https://github.com/sunsx9316/2018/08/26/UITableView+FDTemplateLayoutCell%E8%AE%A1%E7%AE%97%E8%A1%8C%E9%AB%98%E4%B8%80%E4%BA%9B%E7%BC%BA%E9%99%B7%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://github.com/sunsx9316/2018/08/26/UITableView+FDTemplateLayoutCell计算行高一些缺陷的解决方法/</id>
    <published>2018-08-25T16:58:20.706Z</published>
    <updated>2018-08-25T17:59:32.471Z</updated>
    
    <content type="html"><![CDATA[<p>#前言<br>UITableView动态行高一直是iOS的一个经典问题，在没有AutoLayout的时代，只能自己计算<strong>frame</strong>，然后返回给代理，非常痛苦。到了AutoLayout的时代，布局就变得简单多了，甚至于通过系统提供的API都能自动计算出行高。</p><p><a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell">UITableView+FDTemplateLayoutCell</a>就是<a href="https://github.com/sunnyxx">sunnyxx</a>大大的一个自动计算行高的框架。只要布局正确，通过它可以自动计算并缓存行高，非常方便。不过在使用上发现一些问题，也尝试去解决了。</p><p>#过程<br>需求是这样的，一个类似微博的页面，像这样：<br><img src="/sunsx9316/2018/08/26/UITableView+FDTemplateLayoutCell计算行高一些缺陷的解决方法/1320218-1fc431e9a8a7a4f9.jpeg" alt="aimg"></p><p>这应该是比较经典的布局，内容和图片都是不确定的，行高要根据实际数据计算。九宫格实现方式有很多，我这里是通过UICollectionView去实现的。这样的一个好处就是UICollectionView的高度可以通过它的<strong>collectionViewLayout</strong>对象获取，啥都不用算。不过会有一个问题，UICollectionView继承自UIScrollView，它的高度没法按照内容来全显示。所以即使布局正确，通过AutoLayout来计算行高也是不包括UICollectionView的，这个问题同样反映在一些UIView控件上。</p><p>这就十分蛋疼了，难道还要回到手算frame的时代？当然不是，是我还写啥博客。</p><p>我说下解决的几个方法。</p><p><strong>方法一（不推荐）</strong>：手动设置collectionView的高度，可以通过代码或者xib来设置，我这里是xib。</p><p><img src="/sunsx9316/2018/08/26/UITableView+FDTemplateLayoutCell计算行高一些缺陷的解决方法/1320218-decdeddd6bfaee61.png" alt="image.png"></p><p>像这样手动指定collectionView的高度，然后赋值数据源的时候更新collectionView高度约束就可以了，让它的高度等于它的<strong>contentSize.height</strong>，这样就能全部显示了，其它UIView控件也能这么解决。但是这样在计算行高的时候会抛出非常多异常，都是约束的问题。我不是很清楚这是什么原因，按理说计算再后，赋值在前，应该不会这样。而且显示会出一些问题，计算的行高会不正确，有些许误差。</p><p><strong>方法二（推荐）</strong>：既然不能通过这种方式，那就绕个弯吧。去掉高度约束，计算出来的高就不包含collectionView的高。然后再手动加上collectionView的高返回给代理不就行了。不过看下<a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell">UITableView+FDTemplateLayoutCell</a>的拓展方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier</span><br><span class="line">                            configuration:(void (^)(id cell))configuration;</span><br></pre></td></tr></table></figure></p><p>只有一个设置cell数据源的block，正常情况下我们只需要把cell换成我们自己的类，然后赋值模型就行，缓存之类的框架会自动处理好。虽然我们可以获取到缓存高度之后再加上collectionView的高，但是这样还叫啥缓存，缓存就是不需要计算，直接取到就能用，那怎么办呢？<br>虽然可以通过<strong>Method Swizzling</strong>黑魔法交换方法实现，但是这并不是最优方法，往往是一些莫名其妙的bug的源泉，作为开发者应该尽量避免这种方式。所以最后我选择了通过分类的方式。思路是在框架计算完高度之后通过block返回，我们自行处理行高，加加减减，然后返回高度让框架缓存。<br>具体代码：<br>我们参考下框架这个方法的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier</span><br><span class="line">                         cacheByIndexPath:(NSIndexPath *)indexPath</span><br><span class="line">                            configuration:(void (^)(id cell))configuration &#123;</span><br><span class="line">    if (!identifier || !indexPath) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //命中缓存</span><br><span class="line">    if ([self.fd_indexPathHeightCache existsHeightAtIndexPath:indexPath]) &#123;</span><br><span class="line">        [self fd_debugLog:[NSString stringWithFormat:@&quot;hit cache by index path[%@:%@] - %@&quot;, @(indexPath.section), @(indexPath.row), @([self.fd_indexPathHeightCache heightForIndexPath:indexPath])]];</span><br><span class="line">        return [self.fd_indexPathHeightCache heightForIndexPath:indexPath];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //计算行高</span><br><span class="line">    CGFloat height = [self fd_heightForCellWithIdentifier:identifier configuration:configuration];</span><br><span class="line">    [self.fd_indexPathHeightCache cacheHeight:height byIndexPath:indexPath];</span><br><span class="line">    [self fd_debugLog:[NSString stringWithFormat: @&quot;cached by index path[%@:%@] - %@&quot;, @(indexPath.section), @(indexPath.row), @(height)]];</span><br><span class="line"></span><br><span class="line">    return height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它先从缓存中寻找行高，命中之后直接返回。否则计算行高，存入缓存，然后返回。所以很简单，我们可以直接复制它的代码。写一个带编辑行高功能的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">typedef CGFloat(^editCellHeightAction)(id cell, CGFloat cellHeight);</span><br><span class="line"></span><br><span class="line">- (CGFloat)jh_heightForCellWithIdentifier:(NSString *)identifier</span><br><span class="line">                         cacheByIndexPath:(NSIndexPath *)indexPath</span><br><span class="line">                            configuration:(void (^)(id cell))configuration</span><br><span class="line">                               editAction:(editCellHeightAction)editAction &#123;</span><br><span class="line">    if (!identifier || !indexPath) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    // Hit cache</span><br><span class="line">    if ([self.fd_indexPathHeightCache existsHeightAtIndexPath:indexPath]) &#123;</span><br><span class="line">        [self fd_debugLog:[NSString stringWithFormat:@&quot;hit cache by index path[%@:%@] - %@&quot;, @(indexPath.section), @(indexPath.row), @([self.fd_indexPathHeightCache heightForIndexPath:indexPath])]];</span><br><span class="line">        return [self.fd_indexPathHeightCache heightForIndexPath:indexPath];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CGFloat height = 0;</span><br><span class="line">    //获取缓存中的cell</span><br><span class="line">    UITableViewCell *templateLayoutCell = [self fd_templateCellForReuseIdentifier:identifier];</span><br><span class="line">    //这里插入编辑行高的代码</span><br><span class="line">    if (editAction) &#123;</span><br><span class="line">        height = editAction(templateLayoutCell, [self fd_heightForCellWithIdentifier:identifier configuration:configuration]);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        height = [self fd_heightForCellWithIdentifier:identifier configuration:configuration];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [self.fd_indexPathHeightCache cacheHeight:height byIndexPath:indexPath];</span><br><span class="line">    [self fd_debugLog:[NSString stringWithFormat: @&quot;cached by index path[%@:%@] - %@&quot;, @(indexPath.section), @(indexPath.row), @(height)]];</span><br><span class="line">    return height;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用起来像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (CGFloat)tableView:(UITableView *)tableView</span><br><span class="line">heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">     return [tableView jh_heightForCellWithIdentifier:@&quot;MineCell&quot; cacheByIndexPath:indexPath configuration:^(HeSquareCell *cell) &#123;</span><br><span class="line">            //正常赋值数据源</span><br><span class="line">            cell.model = self.model;</span><br><span class="line">        &#125; editAction:^CGFloat(MineCell *cell, CGFloat cellHeight) &#123;</span><br><span class="line">            //cellHeight是上面的block计算后回调过来的 所以直接加上额外的高度即可</span><br><span class="line">            //因为缓存的关系这里只会走一次 所以可以放心写</span><br><span class="line">            return cellHeight + [cell collectionViewHeightWithModel:self.model];</span><br><span class="line">        &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样高度就能正常显示了，而且也不会抛异常，还能享受框架带来的便利。<br><a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell">UITableView+FDTemplateLayoutCell</a>的接口设计很易于拓展，所以写起来很简单。还有个问题，我发现在使用这个框架的时候，如果<code>_tableView.tableFooterView = [[UIView alloc] init];</code>这句话写在注册cell之前，程序会crash，不造为啥。如果各位有更好的解决思路或者文中有错误的地方欢迎给我留言。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#前言&lt;br&gt;UITableView动态行高一直是iOS的一个经典问题，在没有AutoLayout的时代，只能自己计算&lt;strong&gt;frame&lt;/strong&gt;，然后返回给代理，非常痛苦。到了AutoLayout的时代，布局就变得简单多了，甚至于通过系统提供的API都能自
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS的MobileVLCKit框架播放SMB协议视频的问题</title>
    <link href="https://github.com/sunsx9316/2018/08/26/iOS%E7%9A%84MobileVLCKit%E6%A1%86%E6%9E%B6%E6%92%AD%E6%94%BESMB%E5%8D%8F%E8%AE%AE%E8%A7%86%E9%A2%91%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://github.com/sunsx9316/2018/08/26/iOS的MobileVLCKit框架播放SMB协议视频的问题/</id>
    <published>2018-08-25T16:57:02.854Z</published>
    <updated>2018-08-25T16:57:03.313Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://code.videolan.org/videolan/VLCKit" target="_blank" rel="noopener">MobileVLCKit</a>是开源播放器VLC的iOS平台框架，在Mac OS上也有对应的VLCKit，搞直播的同学应该不陌生，不过它其实还是一款强大的本地播放器，支持几乎所有的主流媒体格式。最近在研究app如何浏览电脑上文件，然后直接做到播放视频的功能。用过iOS上的VLC播放器的童鞋应该知道，他能做到扫描本地端口，然后通过输入用户名和密码浏览电脑的文件，点击视频和音频还能直接播放。<br>通过Google知道这里用到一个叫SMB的协议，不光是Mac OS上，Windows和Linux都支持这种协议。只要本地开启SMB的文件共享服务，同一个局域网内的设备就能通过它访问电脑上的文件了。<br>上上<del>gayhub</del>发现了一个SMB的iOS框架，叫<a href="https://github.com/TimOliver/TOSMBClient">TOSMBClient</a>，它将一个C语言的框架封装成了OC的框架。还支持CocoaPods，使用起来非常方便。而<a href="https://code.videolan.org/videolan/VLCKit" target="_blank" rel="noopener">MobileVLCKit</a>原生就支持SMB协议的在线播放。所以解决方案是通过TOSMBClient获取文件列表，VLC播放，想法很美好，但是实际实现还是踩了不少坑。</p><p>先说说SMB的格式，长这样：<code>smb://{hostname}:{password}@{ip}/path</code> 比如桌面上的一个mp4文件就应该长这样：<code>smb://xiaoming:123456@192.168.1.100/xiaoming/Desktop/233.mp4</code><br>hostname是域名，一般创建SMB共享协议的时候，就需要指定。password是密码，ip是服务器的ip。<br><a href="https://github.com/TimOliver/TOSMBClient">TOSMBClient</a>提供了一个登录的类叫<code>TOSMBSession</code>，常用属性是这几个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//服务器域名</span><br><span class="line">@property (nonatomic, copy) NSString *hostName;</span><br><span class="line">//服务器ip</span><br><span class="line">@property (nonatomic, copy) NSString *ipAddress;</span><br><span class="line">//登录的用户名</span><br><span class="line">@property (nonatomic, copy) NSString *userName;</span><br><span class="line">//登录密码</span><br><span class="line">@property (nonatomic, copy) NSString *password;</span><br></pre></td></tr></table></figure></p><p>其中域名和ip可以都设置，也可以只设置其中一个，框架会自动查找。<br>然后通过<code>TOSMBSession</code>提供的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)requestContentsOfDirectoryAtFilePath:(NSString *)path </span><br><span class="line">success:(void (^)(NSArray *files))successHandler</span><br><span class="line"> error:(void (^)(NSError *))errorHandler;</span><br></pre></td></tr></table></figure></p><p>获取文件列表，很简单。返回的files是<code>TOSMBSessionFile</code>类型。它包含基本的文件信息，比如路径，名称，大小。想法挺美好，有URL，直接给VLC播放不就行了，然后就碰到了<strong>第一个坑。</strong><br><code>TOSMBSessionFile</code>提供的路径只是smb格式的一部分，也就只有path部分，所以需要播放还得自己拼接成完整路径。</p><p>拼接好了之后尝试下播放个文件，没带中文的，成功了，高兴之余本着严谨的态度试了下中文路径，结果失败了。NSURL初始化如果包含标准ASCALL以外的字符，会返回nil，这是<strong>第二个坑。</strong></p><p>作为程序员，很自然会想到，URL如果带中文，浏览器会自动做URL转码。所以尝试下转码，发现还是播放失败。这就让我怀疑人生了，怎么肥事？而且连iOS上的VLC的app都有这个问题，这是<strong>第三个坑。</strong></p><p>通过查找API我发现播放器除了通过NSURL初始化，还可以通过NSString初始化，我想，NSURL不让包含中文，NSString总可以吧。结果还是播放失败，神奇的是即使不包含中文，通过NSString初始化还是失败，但是NSURL就可以，这是<strong>第四个坑。</strong></p><p>既然一定要实现功能，那就得搞明白为什么，这时候开源的好处就体现出来了，我看了下<a href="https://code.videolan.org/videolan/VLCKit" target="_blank" rel="noopener">MobileVLCKit</a>的源码，它的媒体类<strong>VLCMedia</strong>是这么写的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithPath:(NSString *)aPath</span><br><span class="line">&#123;</span><br><span class="line">    return [self initWithURL:[NSURL fileURLWithPath:aPath isDirectory:NO]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithURL:(NSURL *)anURL</span><br><span class="line">&#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        const char *url;</span><br><span class="line">        VLCLibrary *library = [VLCLibrary sharedLibrary];</span><br><span class="line">        NSAssert(library.instance, @&quot;no library instance when creating media&quot;);</span><br><span class="line"></span><br><span class="line">        if (([[anURL absoluteString] hasPrefix:@&quot;sftp://&quot;]) ||</span><br><span class="line">            ([[anURL absoluteString] hasPrefix:@&quot;smb://&quot;])) &#123;</span><br><span class="line">            url = [[[anURL absoluteString] stringByRemovingPercentEncoding] UTF8String];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            url = [[anURL absoluteString] UTF8String];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p_md = libvlc_media_new_location(library.instance, url);</span><br><span class="line"></span><br><span class="line">        _metaDictionary = [[NSMutableDictionary alloc] initWithCapacity:3];</span><br><span class="line"></span><br><span class="line">        [self initInternalMediaDescriptor];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，<code>initWithPath:</code>方法把字符串通过<code>fileURLWithPath:isDirectory:</code>方法初始化成URL了，所以smb格式的字符串路径通过这个方法初始化得到的路径肯定是错的，因为它不是标准的本地路径，自然会出现上面神奇的情况。<br>然后看下<code>initWithURL:</code>方法，if语句判断如果包含smb前缀，则做URL解码操作。说明我们的想法是正确的，确实应该对URL进行编码。但是，经过测试编码还是不行，这种情况就很费解了。到现在我还不知道什么原因，因为它自己的APP都有这个问题。不过之后偶然发现了解决方法，很简单<br><strong><br>把URL编码两次即可！！<br>把URL编码两次即可！！<br>把URL编码两次即可！！</strong></p><p>重要的事情说三遍，编码两次之后框架会对URL解码一次，所以得到的URL实际是编码了一次的内容，这样就能播放了，非常神奇，这是<strong>第五个坑。</strong>在这里分享一下给需要的童鞋。</p><p>###注意事项<br>应该只对<code>path</code>、<code>hostname</code>、<code>password</code>部分做URL两次编码，<code>smb://</code>前缀不需要，否则播放器会无法识别。</p><p>2017.10.16日更新 如果发现拼接之后还是没法播放，大部分去因为VLC的版本比较旧的关系，cocoapods里有最新的unstable版本，用这个，不过这个版本也是最不稳定的。<br>2018.7.8日更新 <a href="https://github.com/sunsx9316/SMBPlayerDemo">文章Demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://code.videolan.org/videolan/VLCKit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MobileVLCKit&lt;/a&gt;是开源播放器VLC的iOS平台框架，在Mac OS上也有对应的VLCKit，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="https://github.com/sunsx9316/2018/08/26/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>https://github.com/sunsx9316/2018/08/26/第一篇博客/</id>
    <published>2018-08-25T16:28:22.314Z</published>
    <updated>2018-08-25T16:55:41.870Z</updated>
    
    <content type="html"><![CDATA[<p>最近决定要开始写博客了，打算先把简书的搬过来。这一年接触了很多东西，觉得需要记录下来，自己搭博客还蛮有意思的:)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近决定要开始写博客了，打算先把简书的搬过来。这一年接触了很多东西，觉得需要记录下来，自己搭博客还蛮有意思的:)&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
